{"aspect_id": 1, "aspect_guideline": "## Python Language Rules - Exceptions\nExceptions are allowed but must be used carefully.\n\n### Decisions\nExceptions must follow certain conditions:\n- Make use of built-in exception classes when it makes sense. For example, raise a `ValueError` to indicate a programming mistake like a violated precondition (such as if you were passed a negative number but required a positive one). Do not use `assert` statements for validating argument values of a public API. `assert` is used to ensure internal correctness, not to enforce correct usage nor to indicate that some unexpected event occurred. If an exception is desired in the latter cases, use a raise statement.\n- Never use catch-all `except:` statements, or catch `Exception` or `StandardError`, unless you are\n    - re-raising the exception, or\n    - creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as protecting a thread from crashing by guarding its outermost block.\n  Python is very tolerant in this regard and `except:` will really catch everything including misspelled names, `sys.exit()` calls, Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don\u2019t want to catch.\n- Minimize the amount of code in a `try/except` block. The larger the body of the `try`, the more likely that an exception will be raised by a line of code that you didn\u2019t expect to raise an exception. In those cases, the `try/except` block hides a real error.\n- Use the `finally` clause to execute code whether or not an exception is raised in the `try` block. This is often useful for cleanup, i.e., closing a file.", "criteria": "1. **Usage of Exception Classes**: Verify whether the code makes appropriate use of built-in exception classes (e.g., `ValueError`, `TypeError`, etc.) instead of using generic exceptions or `assert` statements for public API argument validation.\n\n2. **Catch-All Statements**: Evaluate if the code avoids using catch-all `except:` statements or catching generic `Exception` or `StandardError` unless it's for re-raising the exception or for isolation points where exceptions are not propagated but are recorded and suppressed.\n\n3. **Code in Try/Except Block**: Check if the code minimizes the amount of code in a `try/except` block to reduce the likelihood of catching unexpected exceptions that could hide real errors.\n\n4. **Usage of Finally Clause**: Verify whether the code uses the `finally` clause to execute cleanup code regardless of whether an exception was raised in the `try` block.", "demonstrations": [{"input": "```\nimport time\n\nfrom influxdb import InfluxDBClient\nfrom influxdb import SeriesHelper\n\nfrom . import config\n\n# expects Cozify devices type json data\ndef getMultisensorData(data):\n    out = []\n    for device in data:\n        state=data[device]['state']\n        devtype = state['type']\n\n        if devtype == 'STATE_MULTI_SENSOR':\n            name=data[device]['name']\n            if 'lastSeen' in state:\n                timestamp=state['lastSeen']\n            else:\n                # if no time of measurement is known we must make a reasonable assumption\n                # Stored here in milliseconds to match accuracy of what the hub will give you\n                timestamp = time.time() * 1000\n            if 'temperature' in state:\n                temperature=state['temperature']\n            else:\n                temperature=None\n            if 'humidity' in state:\n                humidity=state['humidity']\n            else:\n                humidity=None\n\n            out.append({\n                    'name': name,\n                    'time': timestamp,\n                    'temperature': temperature,\n                    'humidity': humidity\n                    })\n\n    assert type(data) is dict, \"data must be a dictionary\"\n\n    try:\n        client = InfluxDBClient(host=config.INFLUXDB_HOST, port=config.INFLUXDB_PORT)\n        client.create_database('mydb')\n        client.switch_database('mydb')\n        SeriesHelper.init_meta(client=client, measurement='multisensor_data',\n                               tags=['name'], fields=['temperature', 'humidity'])\n        for item in out:\n            SeriesHelper(name=item['name'], time=item['time'],\n                         temperature=item['temperature'], humidity=item['humidity'])\n        SeriesHelper.commit()\n    except:\n        pass\n    return out\n```", "output": "1. **Usage of Exception Classes**:\n    - In the code provided, there is an `assert` statement used to validate that the `data` argument is a dictionary. Assert statements should be avoided for argument validation in public APIs, as they can be turned off globally in the Python interpreter with the `-O` (optimize) switch. Instead, the code should use the appropriate exception class. For example, `TypeError` can be raised to indicate that the wrong type of argument was passed.\n\n2. **Catch-All Statements**:\n    - The code contains a catch-all `except:` statement that suppresses any exception that arises within the `try` block. This practice is dangerous as it can hide unexpected errors, making debugging difficult and possibly allowing the program to continue in an erroneous state. Instead, specific exceptions that are expected to occur should be caught, and appropriate actions should be taken.\n\n3. **Code in Try/Except Block**:\n    - There's a large block of code within a `try/except` block, increasing the risk of catching unexpected exceptions. Code inside a `try` block should be minimized to include only the lines that may raise the expected exceptions.\n\n4. **Usage of Finally Clause**:\n    - The code does not use a `finally` clause for cleanup actions. It is a best practice to use the `finally` clause to ensure that cleanup actions are executed regardless of whether an exception was raised in the `try` block."}, {"input": "```\nfrom rest_framework import serializers\nfrom drf_extra_fields.geo_fields import PointField\nfrom typing import Any, Dict\n\nfrom .models import User\nfrom wallet.serializers import WalletSerializer\n\n\ndef validate_non_negative(value: Any) -> None:\n    \"\"\"Raises a ValueError if the value is negative.\"\"\"\n    if value < 0:\n        raise ValueError(\"Value should be non-negative\")\n\n\nclass UserSerializer(serializers.ModelSerializer):\n    \"\"\" Usage:\n        from rest_framework.renderers import JSONRenderer\n        from semillas_backend.users.serializers import UserSerializer\n\n        JSONRenderer().render(UserSerializer(user_instance).data)\n    \"\"\"\n    location = PointField()\n\n    def create(self, validated_data: Dict[str, Any]) -> User:\n        try:\n            age = validated_data.get(\"age\", None)\n            if age is not None:\n                validate_non_negative(age)\n        except ValueError as e:\n            print(f\"Invalid data: {e}\")\n            raise\n        try:\n            user = User.objects.create(**validated_data)\n        except Exception as e:\n            print(f\"Error while creating user: {e}\")\n            raise\n        return user\n\n    class Meta:\n        model = User\n        fields = ('uuid', 'name', 'picture', 'location', 'username', 'last_login')\n\n\nclass UpdateUserSerializer(serializers.ModelSerializer):\n\n    name = serializers.CharField(required=False)\n    #phone = PhoneNumberField(required=False)\n    email = serializers.CharField(required=False)\n    picture = serializers.ImageField(required=False)\n    uuid = serializers.CharField(read_only=True)\n\n    class Meta:\n        model = User\n        fields = ('name', 'picture', 'phone', 'email', 'uuid')\n\n\nclass FullUserSerializer(UserSerializer):\n\n    wallet = WalletSerializer()\n\n    class Meta:\n        model = User\n        fields = ('uuid', 'name', 'picture', 'location', 'username', 'last_login', 'wallet', 'email', 'phone')\n```", "output": "1. **Usage of Exception Classes**:\n    - The code uses a custom function, `validate_non_negative`, to check if the value of `age` is non-negative. If the value is negative, a `ValueError` is raised with a specific error message, which is good practice for argument validation. This follows the first guideline effectively.\n\n2. **Catch-All Statements**:\n    - The code uses a catch-all `except Exception as e:` statement in the `create` method. While this is not ideal, it is used to catch and log the error message, and then immediately re-raise the original exception. This approach is acceptable according to the second guideline, as it re-raises the caught exception and does not suppress it.\n\n3. **Code in Try/Except Block**:\n    - The code uses separate `try/except` blocks for different operations. In the first block, it validates the age, and in the second block, it creates a user. By separating these operations, the code minimizes the amount of code within each `try/except` block, effectively following the third guideline. This approach makes it easier to identify the source of an exception and reduces the risk of catching unexpected exceptions.\n\n4. **Usage of Finally Clause**:\n    - The code does not have any `finally` clauses. However, it also doesn't have any cleanup actions that need to be executed regardless of whether an exception is raised. Therefore, it doesn't violate the fourth guideline."}, {"input": "```\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nfrom astropy.modeling.fitting import LevMarLSQFitter\nfrom astropy.stats import SigmaClip\n\n\n__all__ = ['EPSFFitter', 'EPSFBuilder']\n\n\nclass EPSFFitter(object):\n    def __init__(self, psf, psf_fit_box=5, fitter=LevMarLSQFitter,\n                 residuals=False, **kwargs):\n        self.psf = psf\n        self.psf_fit_box = psf_fit_box\n        self.fitter = fitter\n        self.residuals = residuals\n        self.fitter_kwargs = kwargs\n\n    def __call__(self, data, psf, star_table):\n        return self.fit_psf(data, psf, star_table)\n\n    def fit_psf(self, data, psf, star_table):\n        pass\n\n\nclass EPSFBuilder(object):\n    def __init__(self, peak_fit_box=5, peak_search_box='fitbox',\n                 recenter_accuracy=1.0e-4, recenter_max_iters=1000,\n                 ignore_badfit_stars=True, stat='median',\n                 sigma_clip=SigmaClip(sigma=3., iters=10),\n                 smoothing_kernel='quar', fitter=EPSFFitter(residuals=True),\n                 max_iters=50, accuracy=1e-4, epsf=None):\n\n        self.peak_fit_box = peak_fit_box\n        self.peak_search_box = peak_search_box\n        self.recenter_accuracy = recenter_accuracy\n        self.recenter_max_iters = recenter_max_iters\n        self.ignore_badfit_stars = ignore_badfit_stars\n        self.stat = stat\n        self.sigma_clip = sigma_clip\n        self.smoothing_kernel = smoothing_kernel\n        self.fitter = fitter\n        self.max_iters = max_iters\n        self.accuracy = accuracy\n        self.epsf = epsf\n\n    def __call__(self, data, star_table):\n        return self.build_psf(data, star_table)\n\n    def build_psf(self, data, star_table):\n        try:\n            # Some code that might raise an exception\n            pass\n        except Exception as e:\n            # Handling the exception\n            pass\n        pass\n```", "output": "1. **Usage of Exception Classes**:\n    - There are no specific argument validation checks or the usage of built-in exception classes in this code snippet. Therefore, we can't evaluate this aspect for this example.\n\n2. **Catch-All Statements**:\n    - The code contains a catch-all `except Exception as e:` statement. It's not clear what exceptions are expected to occur within the `try` block or what the intended behavior is when an exception is caught, as the handler code is a placeholder comment. This does not align with the second guideline, which recommends avoiding catch-all statements unless re-raising the exception or recording and suppressing it at an isolation point. The code should specify the exceptions it expects to handle.\n\n3. **Code in Try/Except Block**:\n    - The code within the `try` block is represented by a placeholder comment. It is not clear what specific operations are being performed, so it is impossible to assess whether the code minimizes the amount of code within the `try/except` block as recommended by the third guideline.\n\n4. **Usage of Finally Clause**:\n    - The code does not use a `finally` clause for cleanup actions. Instead, cleanup code is placed outside of the `try/except` block, which may be acceptable depending on the use case. However, the fourth guideline recommends using a `finally` clause to ensure that cleanup actions are executed regardless of whether an exception was raised in the `try` block."}, {"input": "```\nimport pytest\n\nimport parsl\nfrom parsl.app.app import App\nfrom parsl.data_provider.files import File\nfrom parsl.tests.configs.local_threads import config\n\nparsl.clear()\nparsl.load(config)\n\n\n@App('python')\ndef sort_strings(inputs=[], outputs=[]):\n    with open(inputs[0].filepath, 'r') as u:\n        strs = u.readlines()\n        strs.sort()\n        with open(outputs[0].filepath, 'w') as s:\n            for e in strs:\n                s.write(e)\n\n\n@pytest.mark.local\ndef test_implicit_staging_ftp():\n    \"\"\"Test implicit staging for an ftp file\n\n    Create a remote input file (ftp) that points to file_test_cpt.txt.\n    \"\"\"\n\n    unsorted_file = File('ftp://ftp.cs.brown.edu/pub/info/README')\n\n    # Create a local file for output data\n    sorted_file = File('sorted.txt')\n\n    f = sort_strings(inputs=[unsorted_file], outputs=[sorted_file])\n    f.result()\n\n\nif __name__ == \"__main__\":\n\n    import argparse\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-d\", \"--debug\", action='store_true',\n                        help=\"Count of apps to launch\")\n    args = parser.parse_args()\n\n    if args.debug:\n        parsl.set_stream_logger()\n\n    test_implicit_staging_ftp()\n```", "output": "1. **Usage of Exception Classes**:\n    - The code does not explicitly handle exceptions but relies on external libraries for error handling.\n\n2. **Catch-All Statements**:\n    - The code does not use any catch-all `except:` statements or catch `Exception` or `StandardError`, which is good as it avoids the risks associated with catching unexpected exceptions.\n\n3. **Code in Try/Except Block**:\n    - No `try/except` blocks are present, so there's no risk of catching unexpected exceptions.\n\n4. **Usage of Finally Clause**:\n    - No cleanup actions are present, so the lack of `finally` clauses is appropriate."}]}
{"aspect_id": 2, "aspect_guideline": "## Python Language Rules - Mutable Global State\nModule-level values or class attributes that can get mutated during program execution. Avoid mutable global state.\n\n### Decisions\nAvoid mutable global state.\n\nIn those rare cases where using global state is warranted, mutable global entities should be declared at the module level or as a class attribute and made internal by prepending an `_` to the name. If necessary, external access to mutable global state must be done through public functions or class methods. Please explain the design reasons why mutable global state is being used in a comment or a doc linked to from a comment.\n\nModule-level constants are permitted and encouraged. For example: `_MAX_HOLY_HANDGRENADE_COUNT = 3` for an internal use constant or `SIR_LANCELOTS_FAVORITE_COLOR = \"blue\"` for a public API constant. Constants must be named using all caps with underscores.", "criteria": "1. **Use of Mutable Global State**: Evaluate whether the code uses mutable global state. If so, check if it's really necessary or if the use of mutable global state could be avoided.\n\n2. **Naming Convention for Mutable Global Entities**: Check if any mutable global entities are declared at the module level or as class attributes, and ensure that they are made internal by prepending an underscore (`_`) to the name.\n\n3. **Access to Mutable Global State**: Evaluate whether external access to mutable global state is done through public functions or class methods, as recommended in the guidelines.\n\n4. **Module-level Constants**: Assess if module-level constants are being used appropriately and whether they follow the naming convention of using all caps with underscores.", "demonstrations": [{"input": "```\nimport csv\nimport sys\nimport urllib.error\nimport urllib.request\n\n\nfrom scheduleitem import ScheduleItem\nfrom team import Team\n\n\nteams_data = []\nschedules_data = []\n\ndef read(uri):\n    \"\"\"Open a File or a Web URL\"\"\"\n    if uri.startswith('http://') or uri.startswith('https://'):\n        return open_url(uri)\n    else:\n        return open_local_file(uri)\n\n\ndef open_url(url):\n    \"\"\"Return the game file data.\"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status != 200:\n            msg = 'Status {}. Could Not Open URL {}. Reason: {}'\n            raise urllib.error.HTTPError(\n                msg.format(response.status, url, response.msg)\n            )\n        encoding = sys.getdefaultencoding()\n        return [line.decode(encoding) for line in response.readlines()]\n\n\ndef open_local_file(uri):\n    \"\"\"Return the games file data as an array\"\"\"\n    with open(uri, 'r') as f:\n        return f.readlines()\n\n\ndef load_schedules(uri):\n    global schedules_data\n    data = read(uri)\n    schedules_data = [ScheduleItem.from_str(line) for line in data]\n\n\ndef load_teams_data(data_file):\n    global teams_data\n    with open(data_file, 'r') as csv_file:\n        reader = csv.reader(csv_file)\n        next(reader)  # Skip the header row\n        teams_data = [Team(row[0], row[2], row[3]) for row in reader]\n\n\nmax_holy_handgrenade_count = 3\n```", "output": "1. **Use of Mutable Global State**:\n    - The code uses mutable global state with `teams_data` and `schedules_data` as global lists. This is not recommended, and it's not clear if it's necessary in this case. The use of mutable global state could likely be avoided by returning the data from the functions and passing it as arguments to other functions that need it.\n\n2. **Naming Convention for Mutable Global Entities**:\n    - The mutable global variables `teams_data` and `schedules_data` should be prefixed with an underscore (`_`) to indicate that they are internal. So, they should be renamed as `_teams_data` and `_schedules_data` according to the guidelines.\n\n3. **Access to Mutable Global State**:\n    - The `load_schedules` and `load_teams_data` functions modify the global variables `schedules_data` and `teams_data` directly, which is not recommended. Instead, these functions should return the data, and if necessary, external access to mutable global state should be provided through public functions or class methods.\n\n4. **Module-level Constants**:\n    - The `max_holy_handgrenade_count` should follow the naming convention of using all caps with underscores for module-level constants, so it should be named `MAX_HOLY_HANDGRENADE_COUNT`."}, {"input": "```\nfrom django import forms\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom dal import autocomplete\n\nfrom .models import Course, Options\n\n_MAX_COURSES = 5\nDEFAULT_COURSE_URL = 'semesterpage-course-autocomplete'\n\n_course_count = 0\n\nclass OptionsForm(forms.ModelForm):\n    \"\"\"\n    A form solely used for autocompleting Courses in the admin,\n    using django-autocomplete-light,\n    \"\"\"\n\n    self_chosen_courses = forms.ModelMultipleChoiceField(\n        label=_('Skriv inn fagene du tar n\u00e5'),\n        queryset=Course.objects.all(),\n        widget=autocomplete.ModelSelect2Multiple(\n            url=DEFAULT_COURSE_URL,\n            attrs = {\n                'data-placeholder': _('Tast inn fagkode eller fagnavn'),\n\n                # Only trigger autocompletion after 3 characters have been typed\n                'data-minimum-input-length': 3,\n            },\n        )\n    )\n\n    def __init__(self, *args, **kwargs):\n        super(OptionsForm, self).__init__(*args, **kwargs)\n        self.fields['self_chosen_courses'].help_text = _(\n            'Tast inn fagkode eller fagnavn for \u00e5 legge til et nytt fag\\\n             p\u00e5 hjemmesiden din.'\n        )\n\n    class Meta:\n        model = Options\n        # The fields are further restricted in .admin.py\n        fields = ('__all__')\n\n    @classmethod\n    def increment_course_count(cls):\n        global _course_count\n        _course_count += 1\n\n    @classmethod\n    def get_course_count(cls):\n        return _course_count\n\n    \"\"\"\n    The mutable global state _course_count is being used here to keep track\n    of the number of courses added using this form. This is used to ensure that\n    a maximum of _MAX_COURSES courses are added.\n    \"\"\"\n```", "output": "1. **Use of Mutable Global State**:\n    - The code uses `_course_count` as a mutable global state to track the number of courses added using the form, and this usage is explained in a comment. This usage is acceptable according to the guidelines.\n\n2. **Naming Convention for Mutable Global Entities**:\n    - The mutable global variable `_course_count` is appropriately named with a prepended underscore (`_`) to indicate it's an internal variable, which is in line with the guidelines.\n\n3. **Access to Mutable Global State**:\n    - Access to the mutable global state `_course_count` is done through public class methods `increment_course_count` and `get_course_count`, which follows the guidelines.\n\n4. **Module-level Constants**:\n    - The module-level constants `_MAX_COURSES` and `DEFAULT_COURSE_URL` are properly named using all caps with underscores and are used appropriately in the code."}, {"input": "```\nfrom crispy_forms.bootstrap import FormActions\nfrom crispy_forms.helper import FormHelper\nfrom crispy_forms.layout import Fieldset, Layout, Submit, Div\nfrom django import forms\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom core.widgets import SimpleMDEWidget\nfrom .models import Experiment, Condition\n\nexperimentCount = 0\n\nclass ExperimentCreateForm(forms.ModelForm):\n\n    class Meta:\n        model = Experiment\n        fields = ['name', 'description']\n        widgets = {\n            'description': SimpleMDEWidget(),\n        }\n\n    @cached_property\n    def helper(self):\n        helper = FormHelper()\n        helper.layout = Layout(\n            Fieldset(\n                '',\n                'name',\n                'description',\n            ),\n        )\n        global experimentCount\n        experimentCount += 1\n        return helper\n```", "output": "1. **Use of Mutable Global State**:\n    - The code uses `experimentCount` as a mutable global state to track the number of `ExperimentCreateForm` instances. This usage of mutable global state is not recommended and could likely be avoided. A better approach would be to handle the count of experiments within a class or a module that is responsible for managing experiments.\n\n2. **Naming Convention for Mutable Global Entities**:\n    - The mutable global variable `experimentCount` is not appropriately named. According to the guidelines, it should be prefixed with an underscore (`_`) to indicate it's an internal variable. So, it should be renamed as `_experimentCount`.\n\n3. **Access to Mutable Global State**:\n    - The `helper` method directly modifies the mutable global state `experimentCount` without using a public method or function. This is not recommended. Instead, external access to mutable global state should be done through public functions or class methods.\n\n4. **Module-level Constants**:\n    - There are no module-level constants in this code snippet. Therefore, this aspect is not applicable."}, {"input": "```\nimport logging\nimport sys\n\nimport gym\n\nlogger = logging.getLogger(__name__)\n\nroot_logger = logging.getLogger()\nrequests_logger = logging.getLogger('requests')\n\n# Set up the default handler\nformatter = logging.Formatter('[%(asctime)s] %(message)s')\nhandler = logging.StreamHandler(sys.stderr)\nhandler.setFormatter(formatter)\n\n# We need to take in the gym logger explicitly since this is called\n# at initialization time.\ndef logger_setup(gym_logger):\n    root_logger.addHandler(handler)\n    gym_logger.setLevel(logging.INFO)\n\ndef undo_logger_setup():\n    \"\"\"Undoes the automatic logging setup done by OpenAI Gym. You should call\n    this function if you want to manually configure logging\n    yourself. Typical usage would involve putting something like the\n    following at the top of your script:\n\n    gym.undo_logger_setup()\n    logger = logging.getLogger()\n    logger.addHandler(logging.StreamHandler(sys.stderr))\n    \"\"\"\n    root_logger.removeHandler(handler)\n    gym.logger.setLevel(logging.NOTSET)\n```", "output": "1. **Use of Mutable Global State**:\n   - The code does not use any mutable global state for data storage or to track state across function calls, which is in line with the guidelines.\n\n2. **Naming Convention for Mutable Global Entities**:\n   - There are no mutable global entities in the code that require naming according to the guidelines.\n\n3. **Access to Mutable Global State**:\n   - There is no mutable global state in this code that needs to be accessed through public functions or class methods, as recommended by the guidelines.\n\n4. **Module-level Constants**:\n   - The code does not have any module-level constants, so there's nothing to assess according to this aspect."}]}
{"aspect_id": 3, "aspect_guideline": "## Python Language Rules - Nested/Local/Inner Classes and Functions\nA class can be defined inside of a method, function, or class. A function can be defined inside a method or function. Nested functions have read-only access to variables defined in enclosing scopes. Nested local functions or classes are fine when used to close over a local variable. Inner classes are fine.\n\n### Decisions\nThey are fine with some caveats. Avoid nested functions or classes except when closing over a local value other than `self` or `cls`. Do not nest a function just to hide it from users of a module. Instead, prefix its name with an `_` at the module level so that it can still be accessed by tests.", "criteria": "1. **Use of Nested/Local Functions or Classes**: If the code uses nested or local functions or classes, ensure that they are used for the purpose of closing over a local variable other than `self` or `cls`.\n\n2. **Hiding Functions from Module Users**: Verify that nested functions or classes are not being used just to hide them from users of a module. Instead, check if such functions are prefixed with an underscore (`_`) at the module level so that they can still be accessed by tests.\n\n3. **Access to Variables in Enclosing Scopes**: Ensure that nested functions have read-only access to variables defined in enclosing scopes, as per the guidelines.", "demonstrations": [{"input": "```\nfrom .. import DerivedBase, Property, Base\n\nclass Backup(DerivedBase):\n    api_name = 'backups'\n    api_endpoint = '/linode/instances/{linode_id}/backups/{id}'\n    derived_url_path = 'backups'\n    parent_id_name='linode_id'\n\n    properties = {\n        'id': Property(identifier=True),\n        'created': Property(is_datetime=True),\n        'duration': Property(),\n        'finished': Property(is_datetime=True),\n        'message': Property(),\n        'status': Property(volatile=True),\n        'type': Property(),\n        'linode_id': Property(identifier=True),\n        'label': Property(),\n        'configs': Property(),\n        'disks': Property(),\n        'availability': Property(),\n    }\n\n    def restore_to(self, linode, **kwargs):\n        def process_linode(obj):\n            nonlocal linode\n            if issubclass(type(obj), Base):\n                linode = obj.id\n            else:\n                linode = obj\n\n        process_linode(linode)\n\n        d = {\n            \"linode\": linode,\n        }\n        d.update(kwargs)\n\n        result = self._client.post(\"{}/restore\".format(Backup.api_endpoint), model=self, data=d)\n        return True\n```", "output": "1. **Use of Nested/Local Functions or Classes**:\n    - The code uses a nested function `process_linode` in the `restore_to` method, which isn't closing over a local variable other than `linode`. According to the guidelines, this is not recommended. Instead, it should be a private method or a module-level function with an underscore prefix.\n\n2. **Hiding Functions from Module Users**:\n    - The nested function `process_linode` is defined within the `restore_to` method, which means it is hidden from users of the module. However, this is not the recommended approach to hide functions. Instead of nesting it, the function should be moved to the module level and prefixed with an underscore to indicate it's intended for internal use.\n\n3. **Access to Variables in Enclosing Scopes**:\n    - The nested function modifies the outer scope variable `linode`, which isn't read-only access as suggested by the guidelines. It's safer to avoid modifying variables in the enclosing scope."}, {"input": "```\nfrom __future__ import absolute_import\n\nimport traceback\n\nfrom celery import shared_task\nfrom celery.utils.log import get_task_logger\n\nfrom django.contrib.staticfiles.storage import staticfiles_storage\n\nfrom takeyourmeds.utils.dt import local_time\nfrom takeyourmeds.telephony.utils import send_sms, make_call\n\nfrom .models import Reminder, Time\nfrom .reminders_logging.enums import StateEnum\n\nlogger = get_task_logger(__name__)\n\n@shared_task()\ndef schedule_reminders():\n    for x in Time.objects.filter(time='%02d:00' % local_time().hour):\n        trigger_reminder.delay(x.reminder_id)\n\n@shared_task()\ndef trigger_reminder(reminder_id):\n    reminder = Reminder.objects.get(pk=reminder_id)\n\n    entry = reminder.log_entries.create(\n        state=StateEnum.in_progress,\n    )\n\n    try:\n        entry.state = StateEnum.success\n        entry.twilio_sid = _trigger_reminder(reminder)\n    except Exception as exc:\n        entry.state = StateEnum.error\n        entry.traceback = traceback.format_exc()\n        raise\n    finally:\n        entry.save()\n\ndef _trigger_reminder(reminder):\n    if reminder.message:\n        return send_sms(reminder.phone_number, reminder.message)\n\n    if reminder.audio_url:\n        return make_call(\n            reminder.phone_number,\n            staticfiles_storage.url(reminder.audio_url),\n        )\n\n    raise NotImplementedError(\"Unhandled reminder action\")\n\n\ndef trigger_reminders_for_hour(hour):\n    def _filter_by_hour(hour):\n        return Time.objects.filter(time='%02d:00' % hour)\n\n    reminders = _filter_by_hour(hour)\n    for reminder in reminders:\n        trigger_reminder.delay(reminder.reminder_id)\n```", "output": "1. **Use of Nested/Local Functions or Classes**:\n    - In the function `trigger_reminders_for_hour(hour)`, a nested function `_filter_by_hour(hour)` is used. This is acceptable since it's used to close over a local variable other than `self` or `cls` as per the guidelines.\n\n2. **Hiding Functions from Module Users**:\n    - The `_trigger_reminder(reminder)` function is correctly prefixed with an underscore, indicating it's intended for internal use. It's also at the module level, making it accessible for tests. This follows the guidelines.\n\n3. **Access to Variables in Enclosing Scopes**:\n    - The nested function `_filter_by_hour(hour)` in `trigger_reminders_for_hour(hour)` has read-only access to the `hour` variable from the enclosing scope. This usage is in line with the guidelines."}, {"input": "```\nimport requests\nfrom lxml import html\n\n\nBVG_URL = 'http://mobil.bvg.de/Fahrinfo/bin/stboard.bin/dox?'\n\n\ndef request_station_ids(station_name):\n    ''' Requests the station ids for the provided station name.\n\n    The function has two different outcomes dependend on how distinctive\n    the station name is. A list of possibel stations or the one station.\n\n    Return a tuple (data, ok). Data holdes the <stations> with their name\n    and id. The status flag can be True or False if there are network problems.\n    '''\n\n    def parse_station_data(tree):\n        data = []\n\n        # possible stations\n        if tree.cssselect('span.error'):\n            for station in tree.cssselect('span.select a'):\n                station_name = station.text.strip()\n                # TODO: clean up direct list access\n                station_id = station.get(\"href\").split('&')[1].split('=')[1]\n                data.append((station_name, station_id))\n            return data, True\n\n        # one station\n        # TODO: clean up direct list access\n        station_name = tree.cssselect('span.desc strong')[0].text\n        station_id = tree.cssselect('p.links a')[0].get('href').split('&')[1].split('=')[1]\n        return (station_name, station_id), True\n\n    r = requests.get(BVG_URL, data={'input': station_name})\n\n    # network\n    if r.status_code != 200:\n        return None, False\n\n    tree = html.fromstring(r.content)\n    return parse_station_data(tree)\n```", "output": "1. **Use of Nested/Local Functions or Classes**:\n    - The nested function `parse_station_data(tree)` doesn't close over a local variable other than `self` or `cls`, going against the guidelines. Consider making it a private function at the module level with an underscore prefix.\n\n2. **Hiding Functions from Module Users**:\n    - The nested function `parse_station_data(tree)` is used to hide parsing logic. According to the guidelines, it should be a private function at the module level, prefixed with an underscore.\n\n3. **Access to Variables in Enclosing Scopes**:\n    - The nested function has read-only access to the enclosing scope's variables, which aligns with the guidelines."}, {"input": "```\nimport math\nfrom gpiozero import LED\nfrom time import sleep\n\n\ng0 = LED(12)\nf0 = LED(16)\na0 = LED(20)\nb0 = LED(21)\ne0 = LED(17)\nd0 = LED(27)\nc0 = LED(22)\n\ng1 = LED(25)\nf1 = LED(24)\na1 = LED(23)\nb1 = LED(18)\ne1 = LED(5)\nd1 = LED(6)\nc1 = LED(13)\n\nPITCHES = {\n    'E2': ((a0, d0, e0, f0, g0), (b0, c0)),\n    'A2': ((a0, b0, c0, e0, f0, g0), (d0, )),\n    'D3': ((b0, c0, d0, e0, g0), (a0, f0,)),\n    'G3': ((a0, b0, c0, d0, f0, g0), (e0, )),\n    'B3': ((c0, d0, e0, f0, g0), (a0, b0,)),\n    'E4': ((a0, d0, e0, f0, g0), (b0, c0)),\n}\n\nDIRECTIONS = {\n    -1: ((a1, b1, f1, g1), (c1, d1, e1,)),\n    0: ((g1, ), (a1, b1, c1, d1, e1, f1, )),\n    1: ((c1, d1, e1, g1), (a1, b1, f1)),\n}\n\ndef display_tuning_guidance(pitch, direction):\n    leds_on = PITCHES[pitch][0] + DIRECTIONS[direction][0]\n    leds_off = PITCHES[pitch][1] + DIRECTIONS[direction][1]\n    # Turn the appropriate leds on or off\n    for led in leds_on:\n        led.off()\n    for led in leds_off:\n        led.on()\n```", "output": "1. **Use of Nested/Local Functions or Classes**:\n    - The code doesn't use nested or local functions or classes, so this aspect isn't applicable.\n\n2. **Hiding Functions from Module Users**:\n    - The code doesn't have nested functions or classes used to hide functions from users of the module. All the functions are at the module level, which is recommended. The code follows the guidelines.\n\n3. **Access to Variables in Enclosing Scopes**:\n    - There are no nested functions or classes that have access to variables in enclosing scopes. Therefore, this aspect is not applicable to the code."}]}
{"aspect_id": 4, "aspect_guideline": "## Python Language Rules - Comprehensions & Generator Expressions\nList, Dict, and Set comprehensions as well as generator expressions provide a concise and efficient way to create container types and iterators without resorting to the use of traditional loops, map(), filter(), or lambda. It is okey to use for simple cases.\n\n### Decisions\nOkay to use for simple cases. Each portion must fit on one line: mapping expression, `for` clause, filter expression. Multiple `for` clauses or filter expressions are not permitted. Use loops instead when things get more complicated.", "criteria": "1. **Simplicity**: Check whether comprehensions and generator expressions are being used in simple cases. Evaluate the complexity of the mapping expression, `for` clause, and filter expression. Each portion should fit on one line.\n\n2. **Single `for` and Filter Expressions**: Verify that only a single `for` clause and filter expression is used in the comprehension or generator expression. Multiple `for` clauses or filter expressions should not be permitted.\n\n3. **Use of Loops for Complexity**: Determine if the code uses loops instead of comprehensions when things get more complicated. If comprehensions or generator expressions are complex and not easy to read, evaluate whether replacing them with loops would make the code more understandable.\n\n4. **Use of Descriptive Names**: Check if the code uses descriptive names for the variables in comprehensions and generator expressions, especially when the expressions are more complex.", "demonstrations": [{"input": "```\nfrom gavel import app\nfrom gavel.models import *\nimport gavel.utils as utils\nfrom flask import Response\n\n@app.route('/api/items.csv')\n@utils.requires_auth\ndef item_dump():\n    items = Item.query.order_by(desc(Item.mu)).all()\n    data = [['Mu', 'Sigma Squared', 'Name', 'Location', 'Description', 'Active']]\n\n    data += [(str(i.mu), str(i.sigma_sq), i.name, i.location, i.description, i.active)\n             for i in items if i.active and any(char.isdigit() for char in i.name)]\n\n    return Response(utils.data_to_csv_string(data), mimetype='text/csv')\n\n@app.route('/api/annotators.csv')\n@utils.requires_auth\ndef annotator_dump():\n    annotators = Annotator.query.all()\n    data = [['Name', 'Email', 'Description', 'Secret']]\n\n    data += [(str(a.name), a.email, a.description, a.secret)\n             for a in annotators if a.description and any(char.isdigit() for char in a.name)]\n\n    return Response(utils.data_to_csv_string(data), mimetype='text/csv')\n\n@app.route('/api/decisions.csv')\n@utils.requires_auth\ndef decisions_dump():\n    decisions = Decision.query.all()\n    data = [['Annotator ID', 'Winner ID', 'Loser ID', 'Time']]\n\n    data += [(str(d.annotator.id), str(d.winner.id), str(d.loser.id), str(d.time))\n             for d in decisions if d.time and any(char.isdigit() for char in str(d.annotator.id))]\n\n    return Response(utils.data_to_csv_string(data), mimetype='text/csv')\n```", "output": "1. **Simplicity**:\n    - In the code, the comprehensions in the `item_dump()`, `annotator_dump()`, and `decisions_dump()` functions are not simple, as they involve complex filter expressions.\n\n2. **Single `for` and Filter Expressions**:\n    - In all three functions (`item_dump()`, `annotator_dump()`, and `decisions_dump()`), the comprehensions have multiple filter expressions, violating the guideline that comprehensions should only have one filter expression.\n\n3. **Use of Loops for Complexity**:\n    - Due to the complexity of the filter expressions in the comprehensions, it would be better to use traditional loops to handle these cases.\n\n4. **Use of Descriptive Names**:\n    - The variable names used in the comprehensions (e.g., `i`, `a`, `d`) are not descriptive and can make the code harder to understand."}, {"input": "```\nfrom __future__ import unicode_literals\n\nfrom django.db import models, migrations\nimport jsonfield.fields\nimport dashboard.models\n\ndef _get_default_gender_counts():\n    return {gender: 0 for gender in ['M', 'F', 'O']}\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('dashboard', '0005_auto_20150409_1509'),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name='HouseholdMember',\n            fields=[\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\n                ('gender', models.CharField(max_length=1, choices=[(b'M', b'Male'), (b'F', b'Female'), (b'O', b'Other')])),\n                ('firstName', models.TextField()),\n                ('index', models.SmallIntegerField()),\n                ('muac', models.SmallIntegerField(null=True)),\n                ('birthdate', models.DateField()),\n                ('weight', models.FloatField(null=True)),\n                ('height', models.FloatField(null=True)),\n                ('edema', models.NullBooleanField()),\n                ('household_survey', models.ForeignKey(related_name='members', to='dashboard.HouseholdSurveyJSON')),\n            ],\n            options={\n            },\n            bases=(models.Model,),\n        ),\n        migrations.AddField(\n            model_name='householdsurveyjson',\n            name='household_number',\n            field=models.SmallIntegerField(default=1),\n            preserve_default=False,\n        ),\n        migrations.AddField(\n            model_name='householdsurveyjson',\n            name='gender_counts',\n            field=jsonfield.fields.JSONField(default=_get_default_gender_counts),\n            preserve_default=True,\n        ),\n        migrations.AlterField(\n            model_name='householdsurveyjson',\n            name='json',\n            field=jsonfield.fields.JSONField(help_text=b'A JSON document containing data acquired from one household.  Typically not edited here but uploaded from a mobile application used by a team of surveyors in the field.  If in doubt, do not edit.', validators=[dashboard.models.validate_json]),\n            preserve_default=True,\n        ),\n        migrations.AlterField(\n            model_name='householdsurveyjson',\n            name='team_anthropometrist',\n            field=models.ForeignKey(related_name='householdsurveyjson_surveys_as_team_anthropometrist', to='dashboard.TeamMember'),\n            preserve_default=True,\n        ),\n        migrations.AlterField(\n            model_name='householdsurveyjson',\n            name='team_assistant',\n            field=models.ForeignKey(related_name='householdsurveyjson_surveys_as_team_assistant', to='dashboard.TeamMember'),\n            preserve_default=True,\n        ),\n        migrations.AlterField(\n            model_name='householdsurveyjson',\n            name='team_lead',\n            field=models.ForeignKey(related_name='householdsurveyjson_as_team_lead', to='dashboard.TeamMember'),\n            preserve_default=True,\n        ),\n    ]\n```", "output": "1. **Simplicity**:\n    - The comprehension in the `_get_default_gender_counts` function is simple, consisting of a basic mapping expression and a single `for` clause, which is concise and easy to read.\n\n2. **Single `for` and Filter Expressions**:\n    - The dictionary comprehension in the `_get_default_gender_counts` function uses a single `for` clause and does not have any filter expressions, adhering to the guidelines.\n\n3. **Use of Loops for Complexity**:\n    - The code uses a simple comprehension, and there is no need for loops in this case as the comprehension is straightforward and not complex.\n\n4. **Use of Descriptive Names**:\n    - The variable `gender` used in the comprehension is appropriately named and easy to understand in the context of the code."}, {"input": "```\nimport random\nimport gevent\n\nfrom locust import HttpLocust, TaskSet, task\n\n\nHTTP_USER = \"test\"\nHTTP_PASSWORD = \"1\"\n\nclass NewsAppApi(TaskSet):\n    def get_news(self):\n        self.client.get(\"/news\", auth=(HTTP_USER, HTTP_PASSWORD) )\n\n    def get_single_news(self, news_id):\n        self.client.get(\"/news/{}\".format(news_id), auth=(HTTP_USER, HTTP_PASSWORD),\n                        name=\"/news/{id}\")\n\n    def _make_comment_request(self, method, news_id):\n        self.client.request(method, \"/news/{}/comments\".format(news_id), auth=(HTTP_USER, HTTP_PASSWORD),\n                        name=\"/news/{id}/comments\")\n\n    def get_single_news_comments(self, news_id):\n        self._make_comment_request('GET', news_id)\n\n    def add_news_comment(self, news_id):\n        self._make_comment_request('POST', news_id)\n\n    def edit_news_comment(self, news_id):\n        self._make_comment_request('PUT', news_id)\n\n    def delete_news_comment(self, news_id):\n        self._make_comment_request('DELETE', news_id)\n\n\nclass NormalUserBehavior(NewsAppApi):\n    @task(10)\n    def read_news(self):\n        news_id = random.randint(1, 1000)\n        self.get_single_news(news_id)\n        gevent.sleep(3)\n        self.get_single_news_comments(news_id)\n\n    @task(3)\n    def do_comment_news(self):\n        news_id = random.randint(1, 1000)\n        self.add_news_comment(news_id)\n\n    @task(1)\n    def do_edit_news_comments(self):\n        news_id = random.randint(1, 1000)\n        self.edit_news_comment(news_id)\n\n    @task(1)\n    def do_delete_news_comments(self):\n        news_id = random.randint(1, 1000)\n        self.delete_news_comment(news_id)\n\n    def on_start(self):\n        self.get_news()\n\nclass SpamUserBehavior(NewsAppApi):\n    @task(1)\n    def do_comment_news(self):\n        news_ids = [(i, j) for i in range(1, 11) for j in range(1, 6)]\n        for news_id, comment_id in news_ids:\n            self.add_news_comment(news_id)\n            self.edit_news_comment(comment_id)\n\n    def on_start(self):\n        self.get_news()\n\n\nclass NormalUserLocust(HttpLocust):\n    task_set = NormalUserBehavior\n    weight = 10\n    min_wait = 100\n    max_wait = 500\n\nclass SpamUserLocust(HttpLocust):\n    task_set = SpamUserBehavior\n    weight = 1\n    min_wait = 1\n    max_wait = 1\n```", "output": "1. **Simplicity**:\n    - The list comprehension in the `do_comment_news` method of the `SpamUserBehavior` class introduces unnecessary complexity by combining two ranges.\n\n2. **Single `for` and Filter Expressions**:\n    - The list comprehension `news_ids = [(i, j) for i in range(1, 11) for j in range(1, 6)]` in the `do_comment_news` method of the `SpamUserBehavior` class violates the guideline as it uses multiple `for` clauses. This makes the comprehension less intuitive and harder to follow.\n\n3. **Use of Loops for Complexity**:\n    - Given the dual loops in the comprehension in the `do_comment_news` method, it would be clearer to split this into nested traditional loops to make the intention clear and improve readability.\n\n4. **Use of Descriptive Names**:\n    - The list comprehension in the `do_comment_news` method uses the variables `i` and `j`, which are not descriptive and can make the code harder to understand. Using names like `news_id` and `comment_id` would have been clearer."}, {"input": "```\nimport help_formatter\nimport argparse\n\ndef process_options():\n    parser = _make_options_parser()\n    return parser.parse_args()\n\ndef _make_options_parser():\n    parser = argparse.ArgumentParser(\n        prog='micro',\n        add_help=False,\n        formatter_class=help_formatter.HelpFormatter\n    )\n    parser.add_argument(\n        '-v',\n        '--version',\n        action='version',\n        help='- show the version message and exit',\n        version='Micro interpreter, v2.1\\nCopyright (c) 2016, 2017 thewizardplusplus'\n    )\n    parser.add_argument(\n        '-h',\n        '--help',\n        action='help',\n        help='- show the help message and exit'\n    )\n    parser.add_argument(\n        '-t',\n        '--target',\n        choices=['tokens', 'preast', 'ast', 'evaluation'],\n        default='evaluation',\n        help='- set a target of a script processing'\n    )\n\n    parser.add_argument('script', nargs='?', default='-', help='- a script')\n    parser.add_argument(\n        'args',\n        nargs='*',\n        default=[],\n        help='- script arguments'\n    )\n\n    return parser\n\nif __name__ == '__main__':\n    options = process_options()\n    print(options)\n```", "output": "1. **Simplicity**:\n    - Not applicable, as the provided code does not use comprehensions or generator expressions.\n\n2. **Single `for` and Filter Expressions**:\n    - Not applicable, as the provided code does not use comprehensions or generator expressions.\n\n3. **Use of Loops for Complexity**:\n    - Not applicable, as the provided code does not use comprehensions or generator expressions.\n\n4. **Use of Descriptive Names**:\n    - Not applicable, as the provided code does not use comprehensions or generator expressions."}]}
{"aspect_id": 5, "aspect_guideline": "## Python Language Rules - Default Iterators and Operators\nUse default iterators and operators for types that support them, like lists, dictionaries, and files.\n\n### Decisions\nUse default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it.", "criteria": "1. **Use of Default Iterators**: Check if the code uses the default iterators provided by Python for types that support them, such as lists, dictionaries, and files.\n\n2. **Non-Mutation During Iteration**: Verify that the code does not modify (e.g., add, delete elements) a container (like a list or dictionary) while iterating over it. This can lead to unexpected behavior.", "demonstrations": [{"input": "```\nimport testinfra.utils.ansible_runner\n\ntestinfra_hosts = testinfra.utils.ansible_runner.AnsibleRunner(\n    '.molecule/ansible_inventory').get_hosts('all')\n\n\ndesktop_file_location = \"/root/.local/share/applications/rubymine-2017.2.desktop\"\n\n\ndef test_desktop_file_exists(File):\n    f = File(desktop_file_location)\n\n    assert f.exists\n    assert f.is_file\n\n\ndef test_desktop_file_contains_fullpath(File):\n    f = File(desktop_file_location)\n\n    lines = f.readlines()\n    for line in lines:\n        assert line.strip() == \"/root/Tools/RubyMine-2017.2/bin/rubymine.png\" or \\\n               line.strip() == \"/root/Tools/RubyMine-2017.2/bin/rubymine.sh\"\n\n\ndef test_desktop_file_contains_right_name(File):\n    f = File(desktop_file_location)\n\n    lines = f.readlines()\n    for i, line in enumerate(lines):\n        if \"RubyMine\" in line:\n            lines[i] = line.replace(\"RubyMine\", \"RubyMine Modified\")\n        assert \"RubyMine Modified 2017.2\" in line\n\n\ndef test_start_file_exists(File):\n    f = File('/root/Tools/RubyMine-2017.2/bin/rubymine.sh')\n\n    assert f.exists\n    assert f.is_file\n```", "output": "1. **Use of Default Iterators**:\n    - In `test_desktop_file_contains_fullpath(File)` and `test_desktop_file_contains_right_name(File)`, the code uses `f.readlines()` for iterating over the lines of the file. According to the guidelines, it is preferable to use the default iterators for types that support them, like files. Using `readlines()` will read all the lines into memory, which can be inefficient for large files. It is better to iterate directly over the file object.\n\n2. **Non-Mutation During Iteration**:\n    - In `test_desktop_file_contains_right_name(File)`, the code modifies the `lines` container (a list) while iterating over it. This can lead to unexpected behavior and should be avoided. Instead, it is better to create a new list for storing the modified lines or to postpone modifying the original list until after the iteration."}, {"input": "```\nimport re\nfrom numpy import matrix\n\ninstructions = []\n\nwith open('input.txt', 'r') as f:\n    regex = re.compile(r'([\\w ]+) (\\d+),(\\d+) .+ (\\d+),(\\d+)')\n    for line in f:\n        match = regex.match(line)\n        instructions.append((\n            match.group(1),\n            (int(match.group(2)), int(match.group(3))),\n            (int(match.group(4)), int(match.group(5)))\n        ))\n\nlights = matrix([[0 for i in range(1000)] for j in range(1000)])\n\n\ndef act(instruction):\n    action = instruction[0]\n    x1, y1 = instruction[1]\n    x2, y2 = instruction[2]\n\n    if action == 'turn on':\n        lights[x1:x2, y1:y2] = 1\n    elif action == 'turn off':\n        lights[x1:x2, y1:y2] = 0\n    else:\n        lights[x1:x2, y1:y2] ^= 1\n\n\nfor step in instructions:\n    act(step)\n\nprint(lights.flatten().tolist()[0].count(1))\n\ndef get_ones_count(lights):\n    count = 0\n    for row in lights:\n        for item in row:\n            if item == 1:\n                count += 1\n    return count\n\nprint(get_ones_count(lights))\n```", "output": "1. **Use of Default Iterators**:\n    - In the `with open('input.txt', 'r') as f:` block, the code correctly uses the default iterator for file objects. This adheres to the guidelines and allows for efficient memory usage, especially when dealing with large files.\n\n2. **Non-Mutation During Iteration**:\n    - The code does not modify the `instructions` list or the `lights` matrix while iterating over them. This is in accordance with the guidelines, which recommend not mutating a container while iterating over it to avoid unexpected behavior."}, {"input": "```\nfrom typing import Any\nfrom typing import Callable\n\n# syft relative\nfrom ...messages.group_messages import CreateGroupMessage\nfrom ...messages.group_messages import DeleteGroupMessage\nfrom ...messages.group_messages import GetGroupMessage\nfrom ...messages.group_messages import GetGroupsMessage\nfrom ...messages.group_messages import UpdateGroupMessage\nfrom .request_api import GridRequestAPI\n\nclass GroupRequestAPI(GridRequestAPI):\n    response_key = \"group\"\n    _groups = {}  # internal dictionary to keep track of groups\n\n    def __init__(self, send: Callable):\n        super().__init__(\n            create_msg=CreateGroupMessage,\n            get_msg=GetGroupMessage,\n            get_all_msg=GetGroupsMessage,\n            update_msg=UpdateGroupMessage,\n            delete_msg=DeleteGroupMessage,\n            send=send,\n            response_key=GroupRequestAPI.response_key,\n        )\n\n    def __getitem__(self, key: int) -> Any:\n        return self.get(group_id=key)\n\n    def __delitem__(self, key: int) -> Any:\n        self.delete(group_id=key)\n\n    def add_group(self, key: int, group: Any):\n        self._groups[key] = group\n\n    def remove_group(self, key: int):\n        del self._groups[key]\n\n    def get_group_names(self):\n        group_names = []\n        for group_id, group in self._groups.items():\n            group_names.append(group.name)\n        return group_names\n\n    def update_groups(self):\n        updated_groups = {}\n        for group_id, group in self._groups.items():\n            updated_group = self.get(group_id=group_id)\n            updated_groups[group_id] = updated_group\n            self._groups = updated_groups\n```", "output": "1. **Use of Default Iterators**:\n    - In the `update_groups` method, the code correctly uses the default iterator for dictionaries with the statement `for group_id, group in self._groups.items():`. This adheres to the guidelines.\n\n2. **Non-Mutation During Iteration**:\n    - In the same `update_groups` method, the code modifies the `_groups` dictionary while iterating over it with the statement `self._groups = updated_groups`. This violates the guidelines, as mutating a container during iteration can lead to unexpected behavior."}, {"input": "```\nimport numpy as np\nfrom distarray.client import DistArrayContext, DistArrayProxy\nfrom IPython.parallel import Client\n\nc = Client()\ndv = c[:]\ndac = DistArrayContext(dv)\n\nda = dac.empty((1024, 1024))\nda.fill(2 * np.pi)\n\n\ndef local(context):\n\n    def wrap(fn):\n\n        func_key = context._generate_key()\n        context.view.push({func_key: fn}, targets=context.targets,\n                          block=True)\n        result_key = context._generate_key()\n\n        def inner(a):\n            err_msg_fmt = \"distarray context mismatch: {} {}\"\n            assert context == a.context, err_msg_fmt.format(context, a.context)\n            context._execute('%s = %s(%s)' % (result_key, func_key, a.key))\n            return DistArrayProxy(result_key, context)\n\n        return inner\n\n    return wrap\n\n\n@local(dac)\ndef localsin(da):\n    return np.sin(da)\n\n\n@local(dac)\ndef localadd50(da):\n    return da + 50\n\n\n@local(dac)\ndef localsum(da):\n    return np.sum(da)\n\n\ndv.execute('import numpy as np')\ndb = localsin(da)\ndc = localadd50(da)\ndd = localsum(da)\n#assert_allclose(db, 0)\n```", "output": "1. **Use of Default Iterators**:\n    - The code does not directly iterate over any built-in types like lists, dictionaries, or files, so it does not violate the guideline regarding the use of default iterators.\n\n2. **Non-Mutation During Iteration**:\n    - Not applicable, as the code does not appear to modify any container while iterating over it."}]}
{"aspect_id": 6, "aspect_guideline": "## Python Language Rules - Conditional Expressions\nConditional expressions (sometimes called a \u201cternary operator\u201d) are mechanisms that provide a shorter syntax for if statements. For example: `x = 1 if cond else 2`.\n\n### Decisions\nOkay to use for simple cases. Each portion must fit on one line: true-expression, if-expression, else-expression. Use a complete if statement when things get more complicated.", "criteria": "1. **Simplicity of Conditional Expressions**: Check whether the code uses conditional expressions (ternary operators) for simple cases. The code should avoid using them for complex cases where the true-expression, if-expression, or else-expression doesn't fit in one line.\n\n2. **Appropriate Use of Line Breaks**: Verify that the code uses line breaks appropriately in conditional expressions. The code should avoid line breaks between the 'if' and 'else' clauses, and instead, split the line after the whole conditional expression if necessary.\n\n3. **Use of Complete If Statement**: Determine whether the code switches to a complete if statement when things get more complicated. If the code uses a conditional expression with long or complex portions, check whether replacing it with a full if statement would improve readability.", "demonstrations": [{"input": "```\nimport safe\n\nclass MockResponse(object):\n    def __init__(self, data):\n        self.data = data\n\n    def json(self):\n        return self.data\n\ndef extract_error_message(response_data):\n    error_msg = response_data['error']['message'] if 'error' in response_data and 'message' in response_data['error'] else \"No error message found\"\n    return error_msg\n\ndef test_basic_exception():\n    response = MockResponse({\n        'status': False,\n        'method': 'synchronize',\n        'module': 'cluster',\n        'error': {'message': 'Example error'}\n    })\n\n    error_message = extract_error_message(response.data) if response.data[\n        'status'] == False else \"Operation succeeded\"\n\n    exception = safe.library.raise_from_json(response)\n    assert str(exception) == error_message\n\ndef test_commit_failed_exception():\n    response = MockResponse({\n        'status': False,\n        'type': 'configuration',\n        'method': 'smartapply',\n        'module': 'nsc',\n        'error': {\n            'message': 'Apply configuration failed.',\n            'reason': [{\n                'url': '/SAFe/sng_network_config/modify/network',\n                'obj_type': 'configuration',\n                'type': 'ERROR',\n                'description': 'Default ipv4 gateway is not on eth0 subnet',\n                'module': 'network'\n            }]\n        }\n    })\n\n    if response.data['status'] == False:\n        error_message = \"Apply changes failed: \" + extract_error_message(response.data)\n    else:\n        error_message = \"Operation succeeded\"\n\n    exception = safe.library.raise_from_json(response)\n    assert isinstance(exception, safe.CommitFailed)\n    assert str(exception) == error_message\n    assert len(exception.reasons) == 1\n\n    reason = exception.reasons[0]\n    assert reason.obj == 'configuration'\n    assert reason.module == 'network'\n    assert reason.description == extract_error_message(response.data)\n```", "output": "1. **Simplicity of Conditional Expressions**:\n    - In the `extract_error_message` function, a complex ternary operator is used. This violates the guideline that states that conditional expressions should only be used for simple cases. The condition `'error' in response_data and 'message' in response_data['error']` is too complex for a ternary operator. This can make the code harder to read and understand.\n    - In the `test_commit_failed_exception` function, a complete if statement was used where a simple ternary operator could have sufficed. The condition `response.data['status'] == False` is simple enough that a ternary operator would be appropriate here.\n\n2. **Appropriate Use of Line Breaks**:\n    - In the `test_basic_exception` function, there is a bad use of line breaks in the conditional expression. The line is split between the 'if' and 'else' clauses, which makes it harder to read. According to the guidelines, it is better to split the line after the whole conditional expression if necessary.\n\n3. **Use of Complete If Statement**:\n    - In `test_commit_failed_exception`, a full `if` statement was used in a place where a simple ternary would have been clearer. This goes against the guideline's recommendation to use ternaries for simple cases."}, {"input": "```\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, BooleanField, TextAreaField\nfrom wtforms.validators import DataRequired, Length, Email\n\n\nclass SignupForm(FlaskForm):\n    \"\"\"Render and validate the signup form\"\"\"\n    email = StringField(\"Email\", validators=[DataRequired(), Email(message=\"Invalid email format\"), Length(max=32)])\n    username = StringField(\"Username\", validators=[DataRequired(), Length(2, 32)])\n    password = PasswordField(\"Password\", validators=[DataRequired(), Length(min=4, max=32)])\n\n\nclass LoginForm(FlaskForm):\n    \"\"\"Form to let users login\"\"\"\n    email = StringField(\"Email\", validators=[DataRequired(), Email(message=\"Invalid email format\"), Length(max=32)])\n    password = PasswordField(\"Password\", validators=[DataRequired(), Length(4, 32)])\n    remember = BooleanField(\"Remember Me\")\n\n\nclass BucketlistForm(FlaskForm):\n    \"\"\"Form to CRUd a bucketlist\"\"\"\n    name = StringField(\"Name\", validators=[DataRequired()])\n    description = TextAreaField(\"Description\", validators=[DataRequired()])\n\n    def set_default_description(self):\n        \"\"\"Sets default value for description field based on the name field\"\"\"\n        default_description = (\n            f\"Description for {self.name.data}\"\n            if self.name.data\n            else \"No description provided\"\n        )\n        self.description.data = default_description\n\n\nclass BucketlistItemForm(FlaskForm):\n    \"\"\"Form to CRUd a bucketlist item\"\"\"\n    title = StringField(\"Title\", validators=[DataRequired()])\n    description = TextAreaField(\"Description\", validators=[DataRequired()])\n    status = BooleanField(\"Status\", validators=[DataRequired()])\n```", "output": "1. **Simplicity of Conditional Expressions**:\n    - In the `set_default_description` method of the `BucketlistForm` class, a simple ternary operator is used. This adheres to the guideline that states that conditional expressions should only be used for simple cases. The condition `self.name.data` is straightforward and appropriate for a ternary operator.\n\n2. **Appropriate Use of Line Breaks**:\n    - In the `set_default_description` method, there is an appropriate use of line breaks in the conditional expression. The true-expression, if-expression, and else-expression all fit on one line, which follows the guidelines. The line is not split between the 'if' and 'else' clauses, making it easier to read.\n\n3. **Use of Complete If Statement**:\n    - In this case, there's no need for a complete if statement since the ternary operator is simple and fits on one line. This adheres to the guideline's recommendation to use ternaries for simple cases."}, {"input": "```\nimport requests\n\nfrom .resources.batches import Batches\nfrom .resources.jobs import Jobs\n\nDEFAULT_API_ROOT = 'http://app.spare5.com/partner/v2'\nDEFAULT_USER_AGENT = ('Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/58.0.3029.110 Safari/537')\n\n\nclass Spare5Client(object):\n    def __init__(self, username, token, api_root=DEFAULT_API_ROOT, user_agent=None):\n        super(Spare5Client, self).__init__()\n\n        self.api_root = api_root\n        self.username = username\n        self.token = token\n        self.user_agent = user_agent\n\n        self.batches = Batches(self)\n\n    def _make_request(self, verb, *args, **kwargs):\n        user_agent = (self.user_agent if self.user_agent else DEFAULT_USER_AGENT)\n        kwargs.update({\n            'auth': (self.username, self.token),\n            'headers': {\n                'content-type': 'application/json',\n                'User-Agent': user_agent,\n            },\n        })\n        response = requests.request(verb, *args, **kwargs)\n        return response.json()\n\n    def _get(self, url, **kwargs):\n        return self._make_request('get', url, **kwargs)\n\n    def _post(self, url, data, **kwargs):\n        return self._make_request('post', url, data=data, **kwargs)\n\n    def _put(self, url, data, **kwargs):\n        return self._make_request('put', url, data=data, **kwargs)\n\n    def _delete(self, url, **kwargs):\n        return self._make_request('delete', url, **kwargs)\n```", "output": "1. **Simplicity of Conditional Expressions**:\n    - In the `_make_request` method of the `Spare5Client` class, a simple ternary operator is used. This adheres to the guideline that states that conditional expressions should only be used for simple cases.\n\n2. **Appropriate Use of Line Breaks**:\n    - In the `_make_request` method, the ternary operator is formatted appropriately with the true-expression, if-expression, and else-expression fitting on one line, as per the guidelines. This makes the code easy to read.\n\n3. **Use of Complete If Statement**:\n    - In the `_make_request` method, there's no need for a complete if statement since the ternary operator is simple and fits on one line. This adheres to the guideline's recommendation to use ternaries for simple cases."}, {"input": "```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.template import TemplateDoesNotExist\nfrom django.test import TestCase\n\nfrom core.models import Image\nfrom core.tests import create_user\nfrom users.models import User\n\n\n__all__ = ['CreateImageTest']\n\n\nclass CreateImageTest(TestCase):\n    def setUp(self):\n        self.user = create_user(\"default\")\n        self.client.login(username=self.user.username, password='password')\n\n    def tearDown(self):\n        User.objects.all().delete()\n        Image.objects.all().delete()\n\n    def test_post(self):\n        with open('logo.png', mode='rb') as image:\n            response = self.client.post(reverse('image-list'), {'image': image})\n        image = Image.objects.latest('pk')\n        self.assertEqual(response.json()['id'], image.pk)\n\n    def test_post_error(self):\n        response = self.client.post(reverse('image-list'), {'image': None})\n        self.assertEqual(\n            response.json(),\n            {\n                'image': [\n                    'The submitted data was not a file. '\n                    'Check the encoding type on the form.'\n                ]\n            }\n        )\n```", "output": "1. **Simplicity of Conditional Expressions**:\n    - The code does not use any conditional expressions (ternary operators), so there is no violation of the guidelines.\n\n2. **Appropriate Use of Line Breaks**:\n    - There are no ternary operators in this code, so there is no risk of bad line breaking in a ternary expression.\n\n3. **Use of Complete If Statement**:\n    - Again, there are no ternary operators in this code, so there is no need to consider switching to a full if statement for complex cases."}]}
{"aspect_id": 7, "aspect_guideline": "## Python Language Rules - Properties\nProperties may be used to control getting or setting attributes that require trivial computations or logic. Property implementations must match the general expectations of regular attribute access: that they are cheap, straightforward, and unsurprising.\n\n### Decisions\nProperties are allowed, but, like operator overloading, should only be used when necessary and match the expectations of typical attribute access; follow the getters and setters rules otherwise.\n\nFor example, using a property to simply both get and set an internal attribute isn\u2019t allowed: there is no computation occurring, so the property is unnecessary (make the attribute public instead). In comparison, using a property to control attribute access or to calculate a trivially derived value is allowed: the logic is simple and unsurprising.\n\nProperties should be created with the `@property` decorator. Manually implementing a property descriptor is considered a power feature.\n\nInheritance with properties can be non-obvious. Do not use properties to implement computations a subclass may ever want to override and extend.", "criteria": "1. **Necessity of Properties**: Evaluate whether the properties are necessary and serve a clear purpose, or if they are redundant and could be replaced by public attributes. Properties should only be used when there are trivial computations or logic involved.\n\n2. **Computation in Properties**: Check if the properties perform trivial computations or simple logic, rather than simply getting or setting an internal attribute. Properties should be used to control attribute access or to calculate derived values.\n\n3. **Use of @property Decorator**: Ensure that the properties are created with the `@property` decorator, as manually implementing a property descriptor is considered a power feature and may introduce unnecessary complexity.\n\n4. **Inheritance with Properties**: Verify that properties are not used in situations where a subclass might need to override and extend the computations. Inheritance with properties can be non-obvious and may cause issues with the behavior of the subclasses.", "demonstrations": [{"input": "```\nimport warnings\nfrom collections.abc import Callable\n\nfrom django.conf import settings\nfrom django.utils.module_loading import import_string\n\n\nclass LoginActions:\n    def __init__(self):\n        self._callback = None\n\n    @property\n    def su_login_callback(self):\n        return self._callback\n\n    @su_login_callback.setter\n    def su_login_callback(self, user):\n        if hasattr(settings, 'SU_LOGIN'):\n            warnings.warn(\n                \"SU_LOGIN is deprecated, use SU_LOGIN_CALLBACK\",\n                DeprecationWarning,\n            )\n        func = getattr(settings, 'SU_LOGIN_CALLBACK', None)\n        if func is not None:\n            if not isinstance(func, Callable):\n                func = import_string(func)\n            self._callback = func(user)\n        else:\n            self._callback = user.has_perm('auth.change_user')\n\n    @su_login_callback.deleter\n    def su_login_callback(self):\n        del self._callback\n\n    def custom_login_action(self, request, user):\n        func = getattr(settings, 'SU_CUSTOM_LOGIN_ACTION', None)\n        if func is None:\n            return False\n\n        if not isinstance(func, Callable):\n            func = import_string(func)\n        func(request, user)\n\n        return True\n\n\nclass ExtendedLoginActions(LoginActions):\n    @property\n    def su_login_callback(self):\n        super_callback = super().su_login_callback\n        if super_callback is not None:\n            return super_callback + \"_extended\"\n        return None\n```", "output": "1. **Necessity of Properties**:\n    - The use of the `su_login_callback` property seems unnecessary, as it primarily sets and gets an internal attribute `_callback`. Although the setter method performs some additional operations, the primary action is to set an internal attribute, which could be accomplished with a public attribute. The property seems to add complexity without clear benefit. Ideally, the complex logic within the setter should be moved to a separate method.\n\n2. **Computation in Properties**:\n    - The setter method of the `su_login_callback` property does not perform trivial computations or simple logic. It instead performs a more complex series of operations, including warning generation, function import, and attribute setting. This violates the guideline of using properties only for trivial computations or simple logic.\n\n3. **Use of @property Decorator**:\n    - The code uses the `@property` decorator, but it also implements a setter and a deleter method for the property, which can be considered a power feature and may introduce unnecessary complexity.\n\n4. **Inheritance with Properties**:\n    - The `ExtendedLoginActions` class inherits from the `LoginActions` class and overrides the `su_login_callback` property. This violates the guideline of avoiding the use of properties in situations where a subclass might need to override and extend the computations."}, {"input": "```\nimport django\nfrom datetime import datetime\nimport pytz\nfrom django.db.models import Manager\ndjango.setup()\nfrom basaltApp.models import BasaltImageSet, BasaltSingleImage, BasaltResource\nfrom geocamTrack.utils import getClosestPosition\n\nclass ImageSetInfo:\n    def __init__(self, image_set):\n        self._image_set = image_set\n\n    @property\n    def flight_name(self):\n        return self._image_set.flight.name if self._image_set.flight else \"<none>\"\n\n    @property\n    def position(self):\n        return getClosestPosition(resource=ev1Resource, timestamp=self._image_set.acquisition_time)\n\n    @property\n    def single_images(self):\n        return self._image_set.images.all()\n\n    def display_info(self):\n        print(\"F: %s, N: %s, P: %s\" % (self.flight_name, self._image_set.name, self.position))\n        print(\"  Images:\")\n        for si in self.single_images:\n            print(\"    Thumb: %s (%s x %s)\" % (si.thumbnail, si.width, si.height))\n\nclass ExtendedImageSetInfo(ImageSetInfo):\n    @property\n    def position(self):\n        original_position = super().position\n        return f\"{original_position} (extended)\"\n\nhawaiiStandardTime = pytz.timezone('US/Hawaii')\nstartTime = datetime(2016, 11, 8, 0, 0, 0, tzinfo=hawaiiStandardTime)\nendTime = datetime(2016, 11, 9, 0, 0, 0, tzinfo=hawaiiStandardTime)\nev1Resource = BasaltResource.objects.get(name=\"EV1\")\nprint(\"Resource:\", ev1Resource)\n\nimgList = BasaltImageSet.objects.filter(acquisition_time__gte=startTime).filter(acquisition_time__lte=endTime)\n\nprint(\"Found %d images.\" % imgList.count())\n\nfor img in imgList:\n    image_info = ExtendedImageSetInfo(img)\n    image_info.display_info()\n```", "output": "1. **Necessity of Properties**:\n    - In the `ImageSetInfo` class, the properties (`flight_name`, `position`, and `single_images`) serve clear and necessary purposes. The properties perform trivial computations or simple logic and provide access to relevant information about the image set in a convenient way. This is a valid and appropriate use of properties in this context.\n\n2. **Computation in Properties**:\n    - The properties in the `ImageSetInfo` class perform trivial computations or simple logic. For example, the `flight_name` property calculates the name of the flight, and the `position` property calculates the position of the image set. The `single_images` property provides access to the images associated with the image set. These are all valid computations according to the guidelines.\n\n3. **Use of @property Decorator**:\n    - The properties in the `ImageSetInfo` class are created using the `@property` decorator. This is a straightforward and appropriate way to create properties in Python, as suggested in the guidelines.\n\n4. **Inheritance with Properties**:\n    - The `ExtendedImageSetInfo` class inherits from the `ImageSetInfo` class and overrides the `position` property. While this may serve as an example of inheritance with properties, it goes against the guidelines, which recommend avoiding the use of properties in situations where a subclass might want to override and extend the computations."}, {"input": "```\nimport sys\n\nfrom setuptools import setup\n\n\ndef read_description():\n    with open('README.md', 'r', encoding='utf-8') as f:\n        return f.read()\n\n\nclass PackageInfo:\n    def __init__(self, version):\n        self._version = version\n\n    @property\n    def version(self):\n        return self._version\n\n    @version.setter\n    def version(self, value):\n        self._version = value\n\n\npackage_info = PackageInfo('4.1.1')\npackage_info.version = '4.1.2'\n\nsetup(\n    name='Inject',\n    version=package_info.version,\n    url='https://github.com/ivankorobkov/python-inject',\n    license='Apache License 2.0',\n\n    author='Ivan Korobkov',\n    author_email='ivan.korobkov@gmail.com',\n\n    description='Python dependency injection framework',\n    long_description=read_description(),\n    long_description_content_type=\"text/markdown\",\n\n    packages=['inject'],\n    package_data={'inject': ['py.typed']},\n    zip_safe=False,\n\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Topic :: Software Development :: Libraries :: Python Modules']\n)\n```", "output": "1. **Necessity of Properties**:\n    - The `PackageInfo` class introduces a `version` property that simply gets and sets the `_version` attribute. This use of a property violates the first aspect of the guidelines, as there is no computation or meaningful logic involved in the property. In this case, making the `_version` attribute public (renaming it to `version`) and accessing it directly would be a simpler and more straightforward approach.\n\n2. **Computation in Properties**:\n    - The `version` property does not perform any computation or logic beyond simply getting and setting the `_version` attribute. This is a clear violation of the second aspect of the guidelines, which recommends that properties should be used only when there are trivial computations or logic involved.\n\n3. **Use of @property Decorator**:\n    - The `version` property uses the `@property` decorator, which is in line with the guidelines.\n\n4. **Inheritance with Properties**:\n    - There is no use of inheritance with properties in this code snippet, so it does not violate the fourth aspect of the guidelines."}, {"input": "```\nfrom flask.ext.wtf import Form\nfrom sqlalchemy import Column, UnicodeText, String\nfrom abilian.core.entities import Entity\nfrom abilian.web.frontend import CRUDApp, Module\n\nfrom .base import IntegrationTestCase\n\n\nclass EmailAddress(object):\n  pass\n\n\nclass Contact(Entity):\n  __tablename__ = 'contact'\n\n  email = Column(String, nullable=False)\n  first_name = Column(UnicodeText)\n  last_name = Column(UnicodeText)\n\n\nclass ContactEditForm(Form):\n  _groups = [\n    [u'Main', ['email', 'first_name', 'last_name']]\n  ]\n\n\nclass Contacts(Module):\n  managed_class = Contact\n\n  list_view_columns = [\n    dict(name='_name', width=35),\n    dict(name='partenaire', width=25),\n    dict(name='titre', width=14),\n    dict(name='email', width=20)]\n\n  edit_form_class = ContactEditForm\n\n  related_views = [\n    # TODO\n    #('Visites', 'visites', ('partenaire', 'visiteur', 'date')),\n  ]\n\n\nclass SimpleCRM(CRUDApp):\n  modules = [Contacts()]\n  url = \"/crm\"\n\n\nclass FrontendTestCase(IntegrationTestCase):\n\n  def setUp(self):\n    crm = SimpleCRM(self.app)\n\n  def test(self):\n    pass\n```", "output": "1. **Necessity of Properties**:\n    - This code does not use properties. Instead, it uses simple class attributes and methods for its classes. This is appropriate for the functionality implemented by the classes.\n\n2. **Computation in Properties**:\n    - As there are no properties in the code, there is no computation in properties to evaluate.\n\n3. **Use of @property Decorator**:\n    - There are no properties defined in the code, so the use of the `@property` decorator is not applicable.\n\n4. **Inheritance with Properties**:\n    - No properties are used in the code, so the aspect of inheritance with properties is not applicable."}]}
{"aspect_id": 8, "aspect_guideline": "## Python Language Rules - True/False Evaluations\nPython evaluates certain values as `False` when in a boolean context. A quick \u201crule of thumb\u201d is that all \u201cempty\u201d values are considered false, so `0, None, [], {}, ''` all evaluate as false in a boolean context.\n\n### Decisions\nUse the \"implicit\" false if possible, e.g., `if foo:` rather than `if foo != []:`. There are a few caveats that you should keep in mind though:\n    - Always use `if foo is None:` (or `is not None`) to check for a `None` value. E.g., when testing whether a variable or argument that defaults to `None` was set to some other value. The other value might be a value that\u2019s false in a boolean context!\n    - Never compare a boolean variable to `False` using `==`. Use `if not x:` instead. If you need to distinguish `False` from `None` then chain the expressions, such as `if not x and x is not None:`.\n    - For sequences (strings, lists, tuples), use the fact that empty sequences are false, so `if seq:` and `if not seq:` are preferable to `if len(seq):` and `if not len(seq):` respectively.\n    - When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling `None` as 0). You may compare a value which is known to be an integer (and is not the result of `len()`) against the integer 0.\n    - Note that `'0'` (i.e., `0` as string) evaluates to true.\n    - Note that Numpy arrays may raise an exception in an implicit boolean context. Prefer the `.size` attribute when testing emptiness of a `np.array` (e.g. `if not users.size`).", "criteria": "1. **Implicit False Usage**: Assess whether the code uses the implicit false value where possible. For example, check if the code uses `if foo:` instead of `if foo != []:` or `if not len(foo):`. Ensure that the code takes advantage of the fact that \"empty\" values are considered false in a boolean context.\n\n2. **Checking for None**: Verify that the code uses `if foo is None:` (or `is not None`) to check for a `None` value, especially when testing variables or arguments that default to `None`. Ensure that the code does not inadvertently treat other false values as `None`.\n\n3. **Comparing Boolean Variables**: Ensure that the code does not compare a boolean variable to `False` using `==`. Instead, check that it uses `if not x:`. If the code needs to distinguish `False` from `None`, ensure that it uses chained expressions such as `if not x and x is not None:`.", "demonstrations": [{"input": "```\nfrom twisted.words.protocols import irc\nfrom txircd.modbase import Mode\n\nclass SecretMode(Mode):\n    def checkPermission(self, user, cmd, data):\n        if cmd != \"NAMES\":\n            return data\n        remove = []\n        for chan in data[\"targetchan\"]:\n            if \"p\" in chan.mode and chan.name not in user.channels:\n                user.sendMessage(irc.ERR_NOSUCHNICK, chan, \":No such nick/channel\")\n                remove.append(chan)\n        if len(remove) == 0:\n            return data\n        for chan in remove:\n            data[\"targetchan\"].remove(chan)\n        return data\n\n    def listOutput(self, command, data):\n        if command != \"LIST\":\n            return data\n        cdata = data[\"cdata\"]\n        if not cdata:\n            return data\n        if \"s\" in cdata[\"channel\"].mode and cdata[\"channel\"].name not in data[\"user\"].channels:\n            data[\"cdata\"].clear()\n    # other +s stuff is hiding in other modules.\n\nclass Spawner(object):\n    def __init__(self, ircd):\n        self.ircd = ircd\n        self.mode_s = None\n\n    def spawn(self):\n        self.mode_s = SecretMode()\n        return {\n            \"modes\": {\n                \"cns\": self.mode_s\n            },\n            \"actions\": {\n                \"commandextra\": [self.mode_s.listOutput]\n            }\n        }\n\n    def cleanup(self):\n        self.ircd.removeMode(\"cns\")\n        if self.ircd.actions[\"commandextra\"] == False:\n            return\n        self.ircd.actions[\"commandextra\"].remove(self.mode_s.listOutput)\n```", "output": "1. **Implicit False Usage**:\n    - In the method `checkPermission`, the code uses `if len(remove) == 0:` to check if the list `remove` is empty. This could be better written as `if not remove:`, taking advantage of the fact that empty lists evaluate as `False` in a boolean context.\n\n2. **Checking for None**:\n    - In the method `listOutput`, the code uses `if not cdata:` to check if `cdata` is `None`. This is ambiguous because `cdata` could be an empty list, which would also evaluate to `False`. It would be clearer to use `if cdata is None:`.\n\n3. **Comparing Boolean Variables**:\n    - In the `cleanup` method, the code uses `if self.ircd.actions[\"commandextra\"] == False:` to check if `self.ircd.actions[\"commandextra\"]` is `False`. This could be better written as `if not self.ircd.actions[\"commandextra\"]:`, which is more concise and idiomatic."}, {"input": "```\nimport sys\nfrom os import getcwd, listdir, readlink\nfrom os.path import isdir, islink, join\n\ndef add_value(call, name, value):\n    if value:\n        if call:\n            call += ', '\n        call += '\\\\\\\"%s\\\\\\\": \\\\\\\"%s\\\\\\\"' % (name, value)\n    return call\n\n\ndef add_object(call, name, value):\n    if value:\n        if call:\n            call += ', '\n        call += ('\\\\\\\"%s\\\\\\\": %s' % (name, value)).replace(\"\\'\", '\\\\\\\"')\n    return call\n\n\ndef walk_directory(path=None):\n    global current, development, versions\n\n    if path is None:\n        path = getcwd()\n\n    onlydirs = [d for d in listdir(path) if isdir(join(path, d))]\n    onlydirs.reverse()\n\n    for d in onlydirs:\n        if d == 'current':\n            d_path = join(path, d)\n            if islink(d_path):\n                current = readlink(d_path)\n        elif d.endswith('SNAPSHOT'):\n            development = d\n        elif d and d != current:\n             versions.append(d)\n\ndef build(path=None):\n    global current, development, versions\n    call = ''\n\n    walk_directory(path)\n\n    call = add_value(call, 'development', development)\n    call = add_value(call, 'current', current)\n    call = add_object(call, 'versions', versions)\n\n    target = join(path, 'json-versions.js')\n\n    print('sudo echo \"versionscallback({%s});\" > %s; ls -l' % (call, target))\n\ndef usage():\n    print('Generates a command that creates the \"versionscallback\" JSONP from a CDAP documentation directory on a webserver.')\n    print('Run this with the path to the directory containing the documentation directories.')\n    print('python %s <path>' % sys.argv[0])\n\nif __name__ == '__main__':\n    current = ''\n    development = ''\n    versions = []\n    path = ''\n    if len(sys.argv) > 1:\n        path = sys.argv[1]\n        build(path)\n    else:\n        usage()\n```", "output": "1. **Implicit False Usage**:\n    - The code successfully uses the implicit false value where possible. Specifically, the `add_value` and `add_object` functions utilize the fact that empty strings are considered false in a boolean context, avoiding explicit checks for emptiness.\n\n2. **Checking for None**:\n    - The code correctly uses `if path is None:` instead of `if not path:` to check for a `None` value in the `walk_directory` function. This is essential, especially when testing variables or arguments that default to `None`. The code avoids inadvertently treating other false values as `None`, aligning with the provided guidelines.\n\n3. **Comparing Boolean Variables**:\n    - The code does not have any instances of comparing boolean variables to `False` using `==`. It follows the recommended approach of using `if not x:` instead of `if x == False:`. There are no instances where the code needs to distinguish `False` from `None`, so there are no chained expressions like `if not x and x is not None:`. The code follows the provided guidelines in this regard."}, {"input": "```\nfrom hb_res.storage import ExplanationStorage\nfrom hb_res.explanations.Explanation import Explanation\n\n__author__ = 'skird'\n\n\nclass FileExplanationStorage(ExplanationStorage):\n    \"\"\"\n    Class representing explanation resource connected with some text file\n    \"\"\"\n\n    def __init__(self, path_to_file):\n        self.file_name = path_to_file\n        self.write_desc = None\n\n    def entries(self):\n        if self.write_desc is not None:\n            self.write_desc.flush()\n        with open(self.file_name, encoding='utf-8') as read_desc:\n            for line in read_desc:\n                yield Explanation.decode(line.strip())\n\n    def add_entry(self, entry: Explanation) -> None:\n        if self.write_desc is None:\n            self.write_desc = open(self.file_name, mode='a', encoding='utf-8')\n        print(entry, file=self.write_desc)\n\n    def clear(self) -> None:\n        if self.write_desc is not None:\n            self.write_desc.close()\n        self.write_desc = open(self.file_name, mode='w', encoding='utf-8')\n\n    def close(self) -> None:\n        if self.write_desc is not None:\n            self.write_desc.close()\n\n    def __getitem__(self, key):\n        explanations = [explanation for explanation in self.entries() if explanation.key == key]\n        if len(explanations) == 0:\n            raise KeyError(f'No explanation found with key: {key}')\n        elif len(explanations) > 1:\n            raise ValueError(f'Multiple explanations found with the same key: {key}')\n        else:\n            return explanations[0]\n\n    def has_explanation(self, key):\n        return self.__getitem__(key) == False\n\n```", "output": "1. **Implicit False Usage**:\n    - In the `__getitem__` method, the check for no explanations is done using `if len(explanations) == 0:`. This contravenes the first aspect of the guidelines. Using the implicit false, `if not explanations:`, would be more Pythonic and follow the guidelines.\n\n2. **Checking for None**:\n    - The code does a good job of using `if self.write_desc is not None:` to check for a `None` value. This is correct and adheres to the second aspect of the guidelines.\n\n3. **Comparing Boolean Variables**:\n    - In the `has_explanation` method, the check for an explanation is done using the comparison `== False` instead of the more Pythonic `if not self.__getitem__(key):`. This contravenes the third aspect of the guidelines and can be changed to follow the suggested approach."}, {"input": "```\nimport argparse\n\ndef get_arguments():\n    \"\"\"Set up the argument parser and return an object storing the\n    argument values.\n\n    return - An object storing argument values, as returned by\n    argparse.parse_args()\n\n    \"\"\"\n\n    parser = argparse.ArgumentParser(description=\"Compile C files.\")\n    parser.add_argument(\"file_name\", metavar=\"filename\")\n    return parser.parse_args()\n\ndef compile_code(source: str) -> str:\n    \"\"\"Compile the provided source code into assembly.\n\n    source - The C source code to compile.\n    return - The asm output\n\n    \"\"\"\n    return source\n\ndef main():\n    \"\"\"Load the input files and dispatch to the compile function for the main\n    processing.\n\n    The main function handles interfacing with the user, like reading the\n    command line arguments, printing errors, and generating output files. The\n    compilation logic is in the compile_code function to facilitate testing.\n\n    \"\"\"\n    arguments = get_arguments()\n\n    try:\n        with open(arguments.file_name) as c_file:\n            compile_code(c_file.read())\n    except IOError:\n        print(\"shivyc: error: no such file or directory: '{}'\"\n              .format(arguments.file_name))\n\nif __name__ == \"__main__\":\n    main()\n```", "output": "1. **Implicit False Usage**:\n    - Not applicable. The code does not have any instances where the implicit false value could be utilized. There are no checks against empty strings, lists, or other empty sequences in the code.\n\n2. **Checking for None**:\n    - Not applicable. The code does not have any instances where it is checking for a `None` value. Therefore, there is no need to verify the use of `if foo is None:` or `is not None` in this code.\n\n3. **Comparing Boolean Variables**:\n    - Not applicable. The code does not have any instances where a boolean variable is being compared to `False` using `==`. There are no situations where the code needs to distinguish `False` from `None`."}]}
{"aspect_id": 9, "aspect_guideline": "## Python Language Rules - Function and Method Decorators\nUse decorators judiciously when there is a clear advantage. Avoid `staticmethod` and limit use of `classmethod`.\n\n### Decisions\nUse decorators judiciously when there is a clear advantage. Decorators should follow the same import and naming guidelines as functions.\n\nAvoid external dependencies in the decorator itself (e.g. don\u2019t rely on files, sockets, database connections, etc.), since they might not be available when the decorator runs (at import time, perhaps from `pydoc` or other tools). A decorator that is called with valid parameters should (as much as possible) be guaranteed to succeed in all cases.\n\nDecorators are a special case of \u201ctop-level code\u201d.\n\nNever use `staticmethod` unless forced to in order to integrate with an API defined in an existing library. Write a module-level function instead.\n\nUse `classmethod` only when writing a named constructor, or a class-specific routine that modifies necessary global state such as a process-wide cache.", "criteria": "1. **Avoid External Dependencies in Decorators**: Verify that the decorators in the code do not rely on external dependencies such as files, sockets, database connections, etc. Ensure that the decorators are designed to succeed in all cases when called with valid parameters, even in environments where external dependencies may not be available.\n\n2. **Avoid `staticmethod`**: Evaluate whether the code avoids the use of `staticmethod` unless it is required for integration with an existing library API. Verify that module-level functions are used instead of `staticmethod` when appropriate.\n\n3. **Limit Use of `classmethod`**: Check whether the code uses `classmethod` only when writing a named constructor or a class-specific routine that modifies necessary global state, such as a process-wide cache. Verify that the code does not use `classmethod` inappropriately or excessively.", "demonstrations": [{"input": "```\nimport unittest, pyPdf, sys, os.path\nfrom mock import Mock\n\nSRC = os.path.join(os.path.dirname(__file__), '..', 'src')\nsys.path.append(SRC)\nimport merge\n\nclass MockPdfReader:\n  def __init__(self):\n    self.pages = [None] * 3\n\n  def getNumPages(self):\n    return len(self.pages)\n\n  def getPage(self, page_num): pass\n\nclass MockPdfWriter:\n  def __init__(self):\n    self.pages = []\n\n  def write(self, a_file): pass\n\n  def addPage(self, page): self.pages.append(page)\n\ndef log_execution_time(func):\n    import time\n\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time} seconds.\")\n        return result\n    return wrapper\n\nclass MergeTest(unittest.TestCase):\n  def setUp(self):\n    # Stub the global open method inside the merge module\n    merge.open = Mock(return_value=True)\n\n    self.front_pages = MockPdfReader()\n    self.back_pages = MockPdfReader()\n    self.outfile = MockPdfWriter()\n\n    merge.PdfFileReader = Mock(side_effect=[self.front_pages, self.back_pages])\n    merge.PdfFileWriter = Mock(return_value=self.outfile)\n\n  @staticmethod\n  def log_message(message):\n    print(f\"[MergeTest] {message}\")\n\n  @classmethod\n  def set_test_config(cls, config):\n    cls.config = config\n\n  @log_execution_time\n  def test_merged_file_contains_all_pages(self):\n    merge.merge('fake_doc1', 'fake_doc2', 'fake_out', True, False)\n\n    expected_len = len(self.front_pages.pages) + len(self.back_pages.pages)\n    self.assertEqual(expected_len, len(self.outfile.pages))\n\nif __name__ == '__main__':\n  unittest.main()\n```", "output": "1. **Avoid External Dependencies in Decorators**:\n    - The `log_execution_time` decorator introduces an external dependency on the `time` module, which may not be available when the decorator runs at import time. This violates the guideline against introducing external dependencies in decorators.\n\n2. **Avoid `staticmethod`**:\n    - The `log_message` method is a static method, which violates the guideline against using `staticmethod` unless it is required for integration with an existing library API.\n\n3. **Limit Use of `classmethod`**:\n    - The `set_test_config` method is a class method that does not fit the allowed uses specified in the guidelines. It is not a named constructor or a class-specific routine that modifies necessary global state."}, {"input": "```\nimport os\nfrom setuptools import setup, find_packages\n\ndef handle_exceptions(func):\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return None\n    return wrapper\n\nclass DataDownloader:\n    BASE_URL = 'http://aavso.org/data'\n\n    @classmethod\n    def set_base_url(cls, base_url):\n        \"\"\"Set the base URL for downloading data.\"\"\"\n        cls.BASE_URL = base_url\n\n    @handle_exceptions\n    def download_data(self, data_id):\n        \"\"\"Download data from the AAVSO website.\"\"\"\n        import requests\n        url = f\"{self.BASE_URL}/{data_id}\"\n        response = requests.get(url)\n        response.raise_for_status()\n        return response.content\n\ndef read(fname):\n    return open(os.path.join(os.path.dirname(__file__), fname)).read()\n\nsetup(\n    name='pyaavso',\n    version=__import__('pyaavso').__version__,\n    description='A Python library for working with AAVSO data.',\n    long_description=read('README.rst'),\n    author='Zbigniew Siciarz',\n    author_email='zbigniew@siciarz.net',\n    url='http://github.com/zsiciarz/pyaavso',\n    download_url='http://pypi.python.org/pypi/pyaavso',\n    license='MIT',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    install_requires=['lxml>=2.0', 'requests>=1.0'],\n    tests_require=['pytest'],\n    platforms='any',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Topic :: Scientific/Engineering :: Astronomy',\n        'Topic :: Utilities'\n    ],\n)\n```", "output": "1. **Avoid External Dependencies in Decorators**:\n    - The `handle_exceptions` decorator in the code does not rely on any external dependencies. This adheres to the guideline against introducing external dependencies in decorators.\n\n2. **Avoid `staticmethod`**:\n    - The code does not use `staticmethod`, which complies with the guideline against using `staticmethod` unless it is required for integration with an existing library API.\n\n3. **Limit Use of `classmethod`**:\n    - The `DataDownloader` class in the code has a class method, `set_base_url`, which acts as a named constructor that modifies necessary global state (the base URL for downloading data). This complies with the guideline of limiting the use of class methods to named constructors or class-specific routines that modify necessary global state."}, {"input": "```\nimport json\nimport requests\n\nfrom twisted.internet.defer import inlineCallbacks\nfrom globaleaks.handlers import robots\nfrom globaleaks.models import config\nfrom globaleaks.rest import requests\nfrom globaleaks.settings import GLSettings\nfrom globaleaks.tests import helpers\n\nclass ServerStatus:\n    server_url = 'http://localhost:8080'\n\n    @classmethod\n    def is_server_alive(cls):\n        try:\n            response = requests.get(cls.server_url)\n            return response.status_code == 200\n        except requests.ConnectionError:\n            return False\n\ndef requires_server_alive(func):\n    def wrapper(*args, **kwargs):\n        if ServerStatus.is_server_alive():\n            return func(*args, **kwargs)\n        else:\n            raise Exception('Server is not alive')\n    return wrapper\n\nclass TestRobotstxtHandlerHandler(helpers.TestHandler):\n    _handler = robots.RobotstxtHandler\n\n    @requires_server_alive\n    @inlineCallbacks\n    def test_get_with_indexing_disabled(self):\n        handler = self.request()\n\n        GLSettings.memory_copy.allow_indexing = False\n\n        yield handler.get()\n\n        self.assertEqual(self.responses[0], \"User-agent: *\\n\")\n        self.assertEqual(self.responses[1], \"Disallow: /\")\n\n    @requires_server_alive\n    @inlineCallbacks\n    def test_get_with_indexing_enabled(self):\n        handler = self.request()\n\n        GLSettings.memory_copy.allow_indexing = True\n\n        yield handler.get()\n\n        self.assertEqual(self.responses[0], \"User-agent: *\\n\")\n        self.assertEqual(self.responses[1], \"Allow: /\")\n\nclass TestSitemapHandlerHandler(helpers.TestHandler):\n    _handler = robots.SitemapHandler\n\n    @inlineCallbacks\n    def test_get_with_indexing_disabled(self):\n        handler = self.request()\n\n        GLSettings.memory_copy.allow_indexing = False\n\n        yield handler.get()\n\n        self.assertEqual(handler.get_status(), 404)\n\n    @inlineCallbacks\n    def test_get_with_indexing_enabled(self):\n        handler = self.request()\n\n        GLSettings.memory_copy.allow_indexing = True\n\n        yield handler.get()\n\n        self.assertEqual(handler.get_status(), 200)\n\n\nclass TestAhmiaDescriptionHandler(helpers.TestHandler):\n    _handler = robots.AhmiaDescriptionHandler\n\n    @inlineCallbacks\n    def test_get_ahmia_disabled(self):\n        handler = self.request()\n\n        GLSettings.memory_copy.ahmia = False\n\n        yield handler.get()\n\n        self.assertEqual(handler.get_status(), 404)\n\n    @inlineCallbacks\n    def test_get_ahmia_enabled(self):\n        handler = self.request()\n\n        GLSettings.memory_copy.ahmia = True\n\n        yield handler.get()\n\n        self._handler.validate_message(json.dumps(self.responses[0]), requests.AhmiaDesc)\n```", "output": "1. **Avoid External Dependencies in Decorators**:\n    - The `requires_server_alive` decorator relies on the external dependency of an HTTP server via the `ServerStatus.is_server_alive` class method. This violates the guideline against introducing external dependencies in decorators.\n\n2. **Avoid `staticmethod`**:\n    - The code does not use `staticmethod`, which complies with the guideline against using `staticmethod` unless it is required for integration with an existing library API.\n\n3. **Limit Use of `classmethod`**:\n    - The `ServerStatus` class has a class method `is_server_alive` that checks whether the server is alive by making an HTTP request. This usage does not fit the allowed uses specified in the guidelines. It is not a named constructor or a class-specific routine that modifies necessary global state. This violates the guideline of limiting the use of class methods to appropriate cases."}, {"input": "```\nfrom sqlobject import *\nfrom sqlobject.dberrors import *\nfrom sqlobject.tests.dbtest import *\n\n########################################\n## Table aliases and self-joins\n########################################\n\nclass TestException(SQLObject):\n    name = StringCol(unique=True, length=100)\n\nclass TestExceptionWithNonexistingTable(SQLObject):\n    pass\n\ndef test_exceptions():\n    if not supports(\"exceptions\"):\n        return\n    setupClass(TestException)\n    TestException(name=\"test\")\n    raises(DuplicateEntryError, TestException, name=\"test\")\n\n    connection = getConnection()\n    if connection.module.__name__ != 'psycopg2':\n        return\n    TestExceptionWithNonexistingTable.setConnection(connection)\n    try:\n        list(TestExceptionWithNonexistingTable.select())\n    except ProgrammingError, e:\n        assert e.args[0].code == '42P01'\n    else:\n        assert False, \"DID NOT RAISE\"\n```", "output": "1. **Avoid External Dependencies in Decorators**:\n    - This code does not use any decorators, so it adheres to the guidelines by default.\n\n2. **Avoid `staticmethod`**:\n    - The code does not use any `staticmethod`, so it adheres to the guidelines by default.\n\n3. **Limit Use of `classmethod`**:\n    - The code does not use any `classmethod`, so it adheres to the guidelines by default."}]}
{"aspect_id": 10, "aspect_guideline": "## Python Language Rules - Threading\nDo not rely on the atomicity of built-in types.\n\nWhile Python\u2019s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren\u2019t atomic (e.g. if `__hash__` or `__eq__` are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).\n\nUse the `queue` module\u2019s `Queue` data type as the preferred way to communicate data between threads. Otherwise, use the `threading` module and its locking primitives. Prefer condition variables and `threading.Condition` instead of using lower-level locks.", "criteria": "1. **Avoiding Assumptions About Atomicity of Built-in Types**: Verify that the code does not rely on the atomicity of built-in Python data types, such as dictionaries. Ensure that the code does not assume that operations on built-in data types are atomic, especially when custom implementations of `__hash__` or `__eq__` methods are involved.\n\n2. **Avoiding Atomic Variable Assignment**: Confirm that the code does not rely on atomic variable assignment, as this depends on the atomicity of dictionary operations. Check that the code avoids making assumptions about the atomicity of variable assignments in a multi-threaded context.\n\n3. **Use of `queue.Queue` for Inter-Thread Communication**: Verify that the code uses the `queue` module's `Queue` data type as the preferred way to communicate data between threads. Ensure that the code uses the appropriate methods provided by the `Queue` class for thread-safe communication.\n\n4. **Appropriate Use of Threading Primitives**: Ensure that the code uses the threading module and its associated locking primitives to manage access to shared resources among multiple threads. Verify that the code avoids low-level locking\n\n5. **Preference for Condition Variables**: Verify that the code uses condition variables and `threading.Condition` instead of lower-level locks when appropriate. Ensure that the code uses condition variables effectively for signaling between threads and managing synchronization.", "demonstrations": [{"input": "```\nimport threading\n\nlock = threading.Lock()\nshared_data = {}\natomic_assignment_flag = False\n\ndef worker(segment):\n    global atomic_assignment_flag\n    number, name, format, comments = parseRpl(segment)\n    with lock:\n        if not atomic_assignment_flag:\n            shared_data[number] = {\"name\": name, \"format\": format, \"comments\": comments}\n            atomic_assignment_flag = True\n\ndef parseRpl(segment):\n    after_number = segment.find('</a>')\n    number = segment[after_number-3:after_number]\n\n    at_name = segment.find('</td><td class=\"t\">') + len('</td><td class=\"t\">')\n    after_name = segment.find('</td>', at_name)\n    if segment[at_name:at_name + 7] == '<a href':\n        after_name = segment.find('</a>', after_number + 1)\n        at_name = segment.find('>', at_name) + 1\n    name = segment[at_name:after_name]\n    name = name.rstrip()\n\n    at_format = segment.find('</td><td class=\"t\">', after_name) + len('</td><td class=\"t\">')\n    after_format = segment.find('\\n', at_format)\n    format = segment[at_format: after_format]\n    format = format.replace('&gt;', '>')\n    format = format.replace('&lt;', '<')\n\n    at_comments = segment.find('</td><td>', after_format) + len('</td><td>')\n    comments = segment[at_comments:]\n\n    return number, name, format, comments\n\ndef appendParsed(lines, number, name, format, comments):\n    tab = '    '\n    if len(lines) > 0:\n        lastNumber = lines[-3][0:2]\n        if number == lastNumber:\n            return\n    lines.append(number + tab + name + tab + '\"'+format+'\"' + \"\\n\")\n    lines.append( '### ' + comments)\n    lines.append(\"\\n\")\n\nread = open(\"/home/jlei/files/irc2numerics.html\", \"r\")\nwrite = open(\"/home/jlei/files/numeric_replies.txt\", \"w\")\ntext = read.read()\nread.close()\ntext = text.split('</td></tr>')\nwrite.write(\"###courtesy of pickle@alient.net.au, at http://www.alien.net.au/irc/irc2numerics.html\\n\\n\")\nlines = []\n\nthreads = []\nfor segment in text:\n    thread = threading.Thread(target=worker, args=(segment,))\n    thread.start()\n    threads.append(thread)\n\nfor thread in threads:\n    thread.join()\n\nfor number, data in shared_data.items():\n    appendParsed(lines, number, data[\"name\"], data[\"format\"], data[\"comments\"])\n\nwrite.writelines(lines)\n```", "output": "1. **Avoiding Assumptions About Atomicity of Built-in Types**:\n    - The code is using a built-in dictionary `shared_data` to share data among threads. This can be problematic as dictionary operations may not be atomic in certain scenarios.\n\n2. **Avoiding Atomic Variable Assignment**:\n    - The code uses a shared variable `atomic_assignment_flag` to perform an atomic variable assignment. As mentioned in the guidelines, relying on atomic variable assignment can lead to problems as it depends on the atomicity of dictionary operations.\n\n3. **Use of `queue.Queue` for Inter-Thread Communication**:\n    - The code uses a list as a shared data structure (`lines`) for inter-thread communication instead of `queue.Queue`, which is the recommended way to communicate data between threads as per the guidelines. The `queue.Queue` class is designed to be thread-safe and provides methods for adding and removing items in a way that avoids race conditions. Switching to `queue.Queue` would help ensure safer and more reliable communication between threads.\n\n4. **Appropriate Use of Threading Primitives**:\n    - The code uses a low-level lock (`lock = threading.Lock()`) to manage access to shared resources among multiple threads. Although locks can be useful, the guidelines recommend using condition variables (`threading.Condition`) instead of low-level locks when appropriate. Condition variables provide more advanced synchronization mechanisms, allowing threads to wait for specific conditions to be met and signal each other when changes occur.\n\n5. **Preference for Condition Variables**:\n    - The code does not make use of condition variables or `threading.Condition` for synchronization between threads. Instead, it uses low-level locks. Condition variables would be a more appropriate choice for signaling between threads and managing synchronization in this case. By using condition variables, the code can more effectively handle scenarios where multiple threads need to wait for certain conditions to be met before proceeding."}, {"input": "```\nimport queue\nimport threading\nimport tensorflow as tf\nimport numpy as np\nfrom logging import getLogger\n\nlogging = getLogger(__name__)\n\nclass VariableLoggerHook(tf.train.SessionRunHook):\n    def __init__(self, max_num_variable_values=None):\n        \"\"\"Initializes a VariableLoggerHook.\n\n        Args:\n        max_num_variable_values: If not None, at most max_num_variable_values will\n            be logged per variable.\n        \"\"\"\n        super(VariableLoggerHook, self).__init__()\n        self._max_num_variable_values = max_num_variable_values\n        self._results_queue = queue.Queue()\n\n    def begin(self):\n        \"\"\"Captures all variables to be read out during the session run.\"\"\"\n        self._variables_to_log = tf.contrib.framework.get_variables()\n\n    def before_run(self, run_context):\n        \"\"\"Adds the variables to the run args.\"\"\"\n        return tf.train.SessionRunArgs(self._variables_to_log)\n\n    def after_run(self, run_context, run_values):\n        del run_context\n        original = np.get_printoptions()\n        np.set_printoptions(suppress=True)\n        for variable, variable_value in zip(self._variables_to_log,\n                                            run_values.results):\n            if not isinstance(variable_value, np.ndarray):\n                continue\n            variable_value = variable_value.ravel()\n            logging.info('%s.mean = %s', variable.op.name, np.mean(variable_value))\n            logging.info('%s.std = %s', variable.op.name, np.std(variable_value))\n            if self._max_variable_values:\n                variable_value = variable_value[:self._max_variable_values]\n            logging.info('%s = %s', variable.op.name, variable_value)\n        np.set_printoptions(**original)\n        self._results_queue.put(variable_value)\n\n    def get_results(self):\n        \"\"\"Fetches results from the queue.\"\"\"\n        while not self._results_queue.empty():\n            return self._results_queue.get()\n\n    def process_results(self):\n        \"\"\"Processes results fetched from the queue.\"\"\"\n        condition = threading.Condition()\n        with condition:\n            while self._results_queue.empty():\n                condition.wait()\n            results = self.get_results()\n            # Process results (for example, save them to a file or send them to a server)\n```", "output": "1. **Avoiding Assumptions About Atomicity of Built-in Types**:\n    - The code effectively avoids relying on the atomicity of built-in Python data types. Instead of using dictionaries or other built-in data types for sharing data among threads, it uses a `queue.Queue` object called `_results_queue` to handle inter-thread communication.\n\n2. **Avoiding Atomic Variable Assignment**:\n    - The code does not rely on atomic variable assignment. The use of the `queue.Queue` data structure for inter-thread communication ensures thread-safe operations without the need to make assumptions about atomic assignments.\n\n3. **Use of `queue.Queue` for Inter-Thread Communication**:\n    - The code makes use of the `queue.Queue` object `_results_queue` to communicate data between threads, adhering to the provided guidelines. The code uses the `put` and `get` methods of the `Queue` class for thread-safe communication.\n\n4. **Appropriate Use of Threading Primitives**:\n    - The code uses threading primitives effectively to manage access to shared resources among multiple threads. The `threading.Condition` object is used for synchronization, ensuring that the code adheres to best practices for multi-threading in Python.\n\n5. **Preference for Condition Variables**:\n    - The code successfully uses condition variables and `threading.Condition` instead of lower-level locks for synchronization. The `condition.wait()` method is used to pause execution until results are available in the `_results_queue`."}, {"input": "```\nimport json\nimport threading\n\nfrom http_client import HttpClient\nfrom models.message import ReceivedMessage\n\nclass Bot():\n    \"\"\"\n    @brief Facebook messenger bot\n    \"\"\"\n\n    def __init__(self, token):\n        self.api_token = token\n        self.client = HttpClient(token)\n        self.messages = {}\n\n    def send_message(self, message):\n        response, error = self.client.submit_request(\n                            '/me/messages',\n                            'POST',\n                            message.to_json())\n\n        if error is not None:\n            print('Error Encountered! Could not send message\\n')\n            print(f'Message: {error}')\n\n        return response, error\n\n    def set_welcome(self, message):\n        greeting = {\n            'setting_type': 'greeting',\n            'greeting': {\n                'text': message\n            }\n        }\n\n        data = json.dumps(greeting)\n\n        response, error = self.client.submit_request(\n            '/me/thread_settings',\n            'POST',\n            data)\n\n        return response, error\n\n    def messages_for_request(self, request):\n        \"\"\"\n        Handle incoming requests from the webhook\n        \"\"\"\n        entries = request.json['entry']\n        messages = []\n        for entry in entries:\n            message = {}\n            for msg in entry['messaging']:\n                if msg.get('message') and msg['message'].get('text'):\n                    messages.append(ReceivedMessage(msg))\n\n        return messages\n\n    def message_from_receipt(self, receipt):\n        \"\"\"\n        Handle receipts\n        \"\"\"\n        raise NotImplementedError\n\n    def threaded_message_processor(self):\n        lock = threading.Lock()\n\n        def process_messages():\n            while True:\n                with lock:\n                    for key, messages in self.messages.items():\n                        # Process messages here\n                        del self.messages[key]\n\n        threading.Thread(target=process_messages).start()\n```", "output": "1. **Avoiding Assumptions About Atomicity of Built-in Types**:\n    - The code violates this guideline by relying on the atomicity of dictionary operations. The `messages` dictionary is used to hold incoming messages for processing, and the `threaded_message_processor` method accesses and modifies the dictionary without ensuring atomicity. This could lead to race conditions and data inconsistencies.\n\n2. **Avoiding Atomic Variable Assignment**:\n    - The code does not appear to violate this guideline, as it does not make assumptions about atomic variable assignment in a multi-threaded context.\n\n3. **Use of `queue.Queue` for Inter-Thread Communication**:\n    - The code does not use the `queue` module's `Queue` data type for inter-thread communication. Instead, it uses a dictionary to hold incoming messages, which is not thread-safe and could lead to data inconsistencies. It would be better to use a thread-safe `Queue` object for this purpose.\n\n4. **Appropriate Use of Threading Primitives**:\n    - The code violates this guideline by using low-level locking primitives. The `threaded_message_processor` method uses a low-level `threading.Lock` object to manage access to shared resources, which can lead to potential deadlocks or suboptimal performance. It would be better to use higher-level synchronization primitives like `threading.Condition` or `queue.Queue`.\n\n5. **Preference for Condition Variables**:\n    - The code violates this guideline by using lower-level locks instead of condition variables. The `threaded_message_processor` method uses a low-level lock to manage access to the `messages` dictionary, which could lead to inefficiencies or synchronization issues. Using condition variables would allow the code to wait for specific conditions to be met before proceeding, improving synchronization and reducing the risk of race conditions."}, {"input": "```\nimport atexit\nfrom os import remove\nfrom tempfile import mkstemp\n\nMAX_SOURCES_LENGTH = 8000  # Windows CLI has limit with command length to 8192\n\n\ndef _remove_tmpfile(path):\n    try:\n        remove(path)\n    except WindowsError:  # pylint: disable=E0602\n        pass\n\n\ndef _huge_sources_hook(sources):\n    if len(str(sources)) < MAX_SOURCES_LENGTH:\n        return sources\n\n    _, tmp_file = mkstemp()\n    with open(tmp_file, \"w\") as f:\n        f.write(str(sources).replace(\"\\\\\", \"/\"))\n\n    atexit.register(_remove_tmpfile, tmp_file)\n\n    return \"@%s\" % tmp_file\n\n\ndef exists(_):\n    return True\n\n\ndef generate(env):\n\n    env.Replace(\n        _huge_sources_hook=_huge_sources_hook,\n        ARCOM=env.get(\"ARCOM\", \"\").replace(\n            \"$SOURCES\", \"${_huge_sources_hook(SOURCES)}\"))\n\n    return env\n```", "output": "1. **Avoiding Assumptions About Atomicity of Built-in Types**:\n    - This code does not use any built-in types that would require assumptions about atomicity. There is no multi-threading in this code.\n\n2. **Avoiding Atomic Variable Assignment**:\n    - This code does not rely on atomic variable assignment, as there is no multi-threading in this code.\n\n3. **Use of `queue.Queue` for Inter-Thread Communication**:\n    - This code does not involve inter-thread communication, and hence does not use `queue.Queue`.\n\n4. **Appropriate Use of Threading Primitives**:\n    - This code does not use any threading primitives as it does not involve multi-threading.\n\n5. **Preference for Condition Variables**:\n    - There is no use of condition variables or `threading.Condition` as there is no multi-threading in this code."}]}
{"aspect_id": 11, "aspect_guideline": "## Python Language Rules - Power Features\nPython is an extremely flexible language and gives you many fancy features such as custom metaclasses, access to bytecode, on-the-fly compilation, dynamic inheritance, object reparenting, import hacks, reflection (e.g. some uses of `getattr()`), modification of system internals, `__del__` methods implementing customized cleanup, etc.\n\n### Decisions\nAvoid these features in your code.\n\nStandard library modules and classes that internally use these features are okay to use (for example, `abc.ABCMeta`, `dataclasses`, and `enum`).", "criteria": "1. **Avoidance of Power Features**: Evaluate whether the code refrains from using power features such as custom metaclasses, access to bytecode, on-the-fly compilation, dynamic inheritance, object reparenting, import hacks, reflection, modification of system internals, `__del__` methods implementing customized cleanup, etc. Confirm that the code sticks to standard Python practices and does not use these advanced features.\n\n2. **Use of Standard Library Modules**: Verify that if the code uses any features that are typically considered power features, it does so only through standard library modules and classes that internally use these features. Ensure that the code is using modules and classes like `abc.ABCMeta`, `dataclasses`, and `enum` that are part of the standard library and are considered acceptable according to the guidelines.", "demonstrations": [{"input": "```\nimport sys\nimport os\n\nsys.path.append('.')\nimport roche.settings\n\nfrom os import walk\nfrom eulexistdb.db import ExistDB\nfrom roche.settings import EXISTDB_SERVER_URL\n\n#\n# Timeout higher?\n#\nxmldb = ExistDB(timeout=30)\n\ngetattr(xmldb, 'createCollection')('docker', True)\ngetattr(xmldb, 'createCollection')('docker/texts', True)\n\nos.chdir('../dublin-store')\n\nfor (dirpath, dirnames, filenames) in walk('\u6d59\u6c5f\u5927\u5b78\u5716\u66f8\u9928'):\n    getattr(xmldb, 'createCollection')('docker/texts' + '/' + dirpath, True)\n    if filenames:\n        for filename in filenames:\n            with open(dirpath + '/' + filename) as f:\n                getattr(xmldb, 'load')(f, 'docker/texts' + '/' + dirpath + '/' + filename, True)\n\n#\n# Load resources\n#\nfor (dirpath, dirnames, filenames) in walk('resources'):\n    getattr(xmldb, 'createCollection')('docker' + '/' + dirpath, True)\n    if filenames:\n        for filename in filenames:\n            with open(dirpath + '/' + filename) as f:\n                getattr(xmldb, 'load')(f, 'docker' + '/' + dirpath + '/' + filename, True)\n```", "output": "1. **Avoidance of Power Features**:\n    - The code uses the `getattr()` function, a power feature related to reflection. This adds unnecessary complexity and can introduce security risks. Instead, call the `createCollection` and `load` methods on the `xmldb` object directly.\n\n2. **Use of Standard Library Modules**:\n    - The code does not use power features through standard library modules like `abc.ABCMeta`, `dataclasses`, or `enum`, which is consistent with the guidelines."}, {"input": "```\nfrom django.shortcuts import render\nfrom django.views.generic.list import ListView\nfrom django.views.generic.detail import DetailView\nfrom game.models import Location\nfrom enum import Enum, auto\n\nclass LocationStatus(Enum):\n    UNVISITED = auto()\n    VISITED = auto()\n    COMPLETED = auto()\n\n\nclass LocationListView(ListView):\n\n    template_name = 'game/location_list.html'\n    context_object_name = 'location_list'\n\n    def get_queryset(self):\n        return Location.objects.all()\n\n    def get_context_data(self, **kwargs):\n        context = super(LocationListView, self).get_context_data(**kwargs)\n        return context\n\n\nclass LocationDetailView(DetailView):\n\n    model = Location\n    context_object_name = 'location_detail'\n\n    def get_context_data(self, **kwargs):\n        l_pk = self.kwargs['pk']\n        location = Location.objects.get(pk=l_pk)\n        location.status = LocationStatus.VISITED\n        location.save()\n        context = super(LocationDetailView, self).get_context_data(**kwargs)\n        return context\n```", "output": "1. **Avoidance of Power Features**:\n    - The code adheres to this aspect. No power features are used directly in this code.\n\n2. **Use of Standard Library Modules**:\n    - The code correctly uses the `enum` module from the standard library for defining the `LocationStatus` enumeration. The use of this module is permitted according to the guidelines, as it is a part of the standard library and is considered acceptable for use."}, {"input": "```\nfrom __future__ import print_function\nimport unittest\n\nimport engines\n\nHANDLE = 'mako'\n\n\nclass TestGeneratorMeta(type):\n    def __init__(cls, name, bases, attrs):\n        super(TestGeneratorMeta, cls).__init__(name, bases, attrs)\n\n        def create_test(template, values, expected):\n            def test_method(self):\n                engine = engines.engines[HANDLE]\n                temp = engine(template)\n                result = temp.apply(values)\n                self.assertMultiLineEqual(result, expected)\n            return test_method\n\n        templates_values_expected = [\n            ('Heute gibt es\\n${essen} mit\\n${beilage}.\\n',\n             {'random':  'value', 'essen':   'Szegediner Gulasch', 'beilage': 'Kartoffeln'},\n             'Heute gibt es\\nSzegediner Gulasch mit\\nKartoffeln.\\n')\n        ]\n\n        for i, (template, values, expected) in enumerate(templates_values_expected):\n            setattr(cls, f'test_generated_{i}', create_test(template, values, expected))\n\n\nclass TestStringTemplate(unittest.TestCase, metaclass=TestGeneratorMeta):\n\n    def setUp(self):\n        try:\n            import mako\n        except ImportError:\n            self.skipTest(\"mako module not available\")\n\n    def test_valid_engine(self):\n        self.assertIn(HANDLE, engines.engines)\n        engine = engines.engines[HANDLE]\n        assert issubclass(engine, engines.Engine)\n\n    def test_escape(self):\n        engine = engines.engines[HANDLE]\n\n        template = engine(\n            '<%text>Heute gibt es\\n'\n            '${essen} mit\\n'\n            '${beilage}.\\n</%text>',\n        )\n\n        result = template.apply({\n            'random':  'value',\n            'essen':   'Szegediner Gulasch',\n            'beilage': 'Kartoffeln',\n        })\n\n        self.assertMultiLineEqual(result,\n                                  'Heute gibt es\\n'\n                                  '${essen} mit\\n'\n                                  '${beilage}.\\n',\n                                  )\n\n    def test_conditional(self):\n        engine = engines.engines[HANDLE]\n\n        template = engine(\n            '% if value < 10:\\n'\n            'less than ten\\n'\n            '% else:\\n'\n            'greater or equal\\n'\n            '% endif\\n',\n        )\n\n        result = template.apply({\n            'value':  4,\n        })\n\n        self.assertMultiLineEqual(result,\n                                  'less than ten\\n',\n                                  )\n\n    def test_strict_template_missing_identifier(self):\n        engine = engines.engines[HANDLE]\n\n        template = engine(\n            'Heute gibt es\\n'\n            '${essen} mit\\n'\n            '${beilage}.\\n',\n        )\n\n        self.assertRaises(Exception, template.apply, ({\n            'random':  'value',\n        }))\n\n    def test_tolerant_template_missing_identifier(self):\n        engine = engines.engines[HANDLE]\n\n        template = engine(\n            'Heute gibt es\\n'\n            '${essen} mit\\n'\n            '${beilage}.\\n',\n            tolerant=True,\n        )\n\n        result = template.apply({\n            'random':  'value',\n        })\n\n        self.assertMultiLineEqual(result,\n                                  'Heute gibt es\\n'\n                                  '<UNDEFINED> mit\\n'\n                                  '<UNDEFINED>.\\n'\n                                  )\n\n\nif __name__ == '__main__':\n    unittest.main()\n```", "output": "1. **Avoidance of Power Features**:\n    - The code uses a custom metaclass, `TestGeneratorMeta`, to dynamically create test methods. This is a power feature that should be avoided according to the guidelines.\n\n2. **Use of Standard Library Modules**:\n    - The code does not use power features through standard library modules like `abc.ABCMeta`, `dataclasses`, or `enum`. In this case, the direct use of a custom metaclass is problematic and not consistent with the guidelines."}, {"input": "```\nimport ast\n\nimport pytest\nfrom simtk import unit\n\nfrom openforcefield.typing.engines.smirnoff.io import (\n    _ast_unit_eval,\n    _extract_attached_units,\n)\n\n\n#=============================================================================================\n# QUANTITY PARSING UTILITIES\n#=============================================================================================\n\n@pytest.mark.parametrize('unit_string,expected_unit',[\n    ('kilocalories_per_mole', unit.kilocalories_per_mole),\n    ('kilocalories_per_mole/angstrom**2', unit.kilocalories_per_mole/unit.angstrom**2),\n    ('joule/(mole * nanometer**2)', unit.joule/(unit.mole * unit.nanometer**2)),\n    ('picosecond**(-1)', unit.picosecond**(-1)),\n    ('300.0 * kelvin', 300*unit.kelvin),\n    ('1 * kilojoule + 500 * joule', 1.5*unit.kilojoule),\n    ('1 / meter', 1.0 / unit.meter)\n])\ndef test_ast_unit_eval(unit_string, expected_unit):\n    \"\"\"Test that _ast_unit_eval() correctly parses string quantities.\"\"\"\n    ast_root_node = ast.parse(unit_string, mode='eval').body\n    parsed_units = _ast_unit_eval(ast_root_node)\n    assert parsed_units == expected_unit\n\n\n@pytest.mark.parametrize('attributes,expected',[\n    ({'not_parsed': 'blabla'},\n        {}),\n    ({'not_parsed': 'blabla', 'attr_unit': 'angstrom/femtosecond'},\n        {'attr': unit.angstrom/unit.femtosecond}),\n    ({'not_parsed': 'blabla', 'attr1_unit': 'meter', 'attr2_unit': 'kilojoule_per_mole'},\n        {'attr1': unit.meter, 'attr2': unit.kilojoule_per_mole}),\n])\ndef test_extract_attached_units(attributes, expected):\n    \"\"\"Test that _extract_attached_units() correctly parses the correct.\"\"\"\n    assert _extract_attached_units(attributes) == expected\n\n\n@pytest.mark.parametrize('attributes',[\n    {'attr_unit': '300.0 * kelvin'},\n    {'attr_unit': '1 / picosecond'}\n])\ndef test_extract_attached_units_raises(attributes):\n    \"\"\"Test that _extract_attached_units() raises an error when a quantity is specified instead of a unit.\"\"\"\n    with pytest.raises(ValueError, match='associated to a quantity rather than only units'):\n        _extract_attached_units(attributes)\n```", "output": "1. **Avoidance of Power Features**:\n    - The code does not use any power features mentioned in the guidelines.\n\n2. **Use of Standard Library Modules**:\n    - Not applicable, as the code does not use any power features mentioned in the guidelines."}]}
{"aspect_id": 12, "aspect_guideline": "## Python Style Rules - Strings\nUse an f-string, the `%` operator, or the `format` method for formatting strings, even when the parameters are all strings. Use your best judgment to decide between string formatting options. A single join with `+` is okay but do not format with `+`.\n\nAvoid using the `+` and `+=` operators to accumulate a string within a loop. In some conditions, accumulating a string with addition can lead to quadratic rather than linear running time. Although common accumulations of this sort may be optimized on CPython, that is an implementation detail. The conditions under which an optimization applies are not easy to predict and may change. Instead, add each substring to a list and ''.join the list after the loop terminates, or write each substring to an io.StringIO buffer. These techniques consistently have amortized-linear run-time complexity.", "criteria": "1. **String Formatting**: Assess whether the code uses appropriate string formatting methods such as f-strings, the `%` operator, or the `format` method. Confirm that the code does not use string concatenation with `+` for formatting purposes.\n\n2. **String Accumulation in Loops**: Confirm that the code avoids using `+` and `+=` to accumulate strings within a loop, as it can result in quadratic running time. Evaluate whether the code uses alternative approaches, such as appending each substring to a list and joining the list after the loop, or writing each substring to an `io.StringIO` buffer.", "demonstrations": [{"input": "```\nfrom django.conf import settings\n\nimport xlrd\nimport os\n\n\nbase_loader_error = 'The Loader class can only be used by extending it.'\n\n\nextensions = getattr(\n    settings,\n    'IMPORTER_EXTENSIONS',\n    {\n        'excel': ('.xls', '.xlsx'),\n    }\n)\n\n\nclass Loader(object):\n    def __init__(self, file_info, autoload=True):\n        self.filename = \"/data/\" + file_info.path\n\n        if autoload is True:\n            return self.open()\n\n    def open(self):\n        raise NotImplementedError(base_loader_error)\n\n    def close(self):\n        pass\n\n    @classmethod\n    def sniff(cls, file_info):\n        raise NotImplementedError(base_loader_error)\n\n\nclass ExcelLoader(Loader):\n    supports_sheets = True\n    type_name = 'excel'\n\n    def open(self):\n        self.backend = xlrd.open_workbook(self.filename)\n        self.sheet_names = self.backend.sheet_names()\n        self.sheet_count = len(self.sheet_names)\n\n    def close(self):\n        self.backend.release_resources()\n\n    @classmethod\n    def sniff(cls, file_info):\n        if not 'excel' in extensions: return False\n        return os.path.splitext(file_info.path)[-1] in extensions['excel']\n\n    def sheet_by_name(self, name):\n        \"\"\" Returns a sheet based on its name. \"\"\"\n        return self.backend.sheet_by_name(name)\n\n    def get_all_sheet_names(self):\n        all_sheet_names = 'Sheet names: '\n        for sheet_name in self.sheet_names:\n            all_sheet_names += sheet_name + ', '\n        return all_sheet_names[:-2]\n\n\nclass CSVLoader(Loader):\n    supports_sheets = False\n```", "output": "1. **String Formatting**:\n    - In the `Loader` class, the `self.filename` attribute is initialized by concatenating a string literal with the `file_info.path` using the `+` operator. It is more appropriate to use string formatting methods here.\n\n2. **String Accumulation in Loops**:\n    - In the `ExcelLoader` class, the `get_all_sheet_names` method accumulates sheet names into the `all_sheet_names` string using the `+=` operator within a loop. This is not the most efficient way to accumulate strings, and alternative approaches should be used."}, {"input": "```\nimport os\n\nMODELDIR = \"etc/defaultmodels\"\n\ndef symlink_model_fixtures():\n    \"\"\"\n    Create symlinks between the files referenced in the OcrModel\n    fixtures and our default model files.  Need to do this because\n    they get deleted again at test teardown.\n    \"\"\"\n    for fname in os.listdir(MODELDIR):\n        try:\n            os.makedirs(\"media/test\")\n        except OSError as e:\n            if e.errno == 17: # already exists\n                pass\n\n        try:\n            src_path = os.path.abspath(f\"{MODELDIR}/{fname}\")\n            dest_path = f\"media/test/{fname}\"\n            os.symlink(src_path, dest_path)\n        except OSError as e:\n            if e.errno == 17: # already exists\n                pass\n\n\ndef symlink_reference_pages():\n    \"\"\"\n    Create a symlink for the reference page images.\n    \"\"\"\n    try:\n        os.makedirs(\"media/test\")\n    except OSError as e:\n        if e.errno == 17: # already exists\n            pass\n\n        try:\n            src_path1 = os.path.abspath(\"etc/simple.png\")\n            dest_path1 = \"media/test/test.png\"\n            src_path2 = os.path.abspath(\"etc/simple.png\")\n            dest_path2 = \"media/test/test_bin.png\"\n            os.symlink(src_path1, dest_path1)\n            os.symlink(src_path2, dest_path2)\n        except OSError as e:\n            if e.errno == 17: # already exists\n                pass\n\ndef concatenate_strings(strings):\n    \"\"\"\n    Concatenate a list of strings.\n    \"\"\"\n    return ''.join(strings)\n```", "output": "1. **String Formatting**:\n    - The code uses f-strings for string formatting. This is evident in the `symlink_model_fixtures` and `symlink_reference_pages` methods where the code now uses f-strings for string concatenation, which is a recommended approach in the guidelines.\n\n2. **String Accumulation in Loops**:\n    - The new method `concatenate_strings` is a good demonstration of the recommended approach for string accumulation within a loop. It uses the `''.join(strings)` method, which is a recommended way of accumulating strings according to the guidelines provided. This method is an efficient way to concatenate strings and prevents the quadratic running time that can occur when using the `+` or `+=` operators within a loop."}, {"input": "```\nimport unittest\nimport sys\nsys.path.insert(0, '../mafia')\n\nfrom game import Game\nfrom game import Player\n\nclass TestMessenger:\n    def message_all_players(self, message: str):\n        print ('public: {message}'.format(message=message))\n\n    def message_player(self, player, message: str):\n        print ('{name}: {message}'.format(name=player.nickname, message=message))\n\ndef summarize_actions(game):\n    summary = \"Actions Summary:\\n\"\n    for action in game.actions:\n        summary += f\"{action['player'].nickname} targeted {action['target'].nickname} with action {action['action']}\\n\"\n    return summary\n\nclass SmokeTest(unittest.TestCase):\n    def setUp(self):\n        self.messenger = TestMessenger()\n\n    def test_smoke_test(self):\n        game = Game('t,c,c,m', self.messenger)\n        player_one = Player('one', 'one')\n        player_two = Player('two', 'two')\n        player_three = Player('three', 'three')\n        player_four = Player('four', 'four')\n        game.join(player_one)\n        game.join(player_two)\n        game.join(player_three)\n        game.join(player_four)\n        game.vote('one', 'three')\n        game.vote('three', 'one')\n        game.vote('two', 'three')\n        game.vote('four', 'three')\n        game.target('one', 'two')\n        game.target('two', 'one')\n        game.target('four', 'one')\n        print(summarize_actions(game))\n\nif __name__ == '__main__':\n    unittest.main()\n```", "output": "1. **String Formatting**:\n    - The code uses f-strings for string formatting, which is recommended in the guidelines. This is evident in the `summarize_actions` function, where the code uses f-strings to construct the action summary.\n\n2. **String Accumulation in Loops**:\n    - The code violates the second aspect of the guidelines by using the `+=` operator to accumulate strings within a loop in the `summarize_actions` function."}, {"input": "```\nfrom ez_setup import use_setuptools\nuse_setuptools()\n\nfrom setuptools import setup, find_packages\nfrom setuptools.command.test import test\n\nfrom django_evolution import get_package_version, VERSION\n\n\ndef run_tests(*args):\n    import os\n    os.system('tests/runtests.py')\n\ntest.run_tests = run_tests\n\n\nPACKAGE_NAME = 'django_evolution'\n\ndownload_url = (\n    'http://downloads.reviewboard.org/releases/django-evolution/%s.%s/' %\n    (VERSION[0], VERSION[1]))\n\n\n# Build the package\nsetup(\n    name=PACKAGE_NAME,\n    version=get_package_version(),\n    description='A database schema evolution tool for the Django web framework.',\n    url='http://code.google.com/p/django-evolution/',\n    author='Ben Khoo',\n    author_email='khoobks@westnet.com.au',\n    maintainer='Christian Hammond',\n    maintainer_email='christian@beanbaginc.com',\n    download_url=download_url,\n    packages=find_packages(exclude=['tests']),\n    install_requires=[\n        'Django>=1.4.10',\n    ],\n    include_package_data=True,\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Framework :: Django',\n        'Intended Audience :: Developers',\n        'Natural Language :: English',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Topic :: Software Development',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ]\n)\n```", "output": "1. **String Formatting**:\n    - In the code, the `download_url` variable is initialized using the `%` operator for string formatting. This is one of the recommended approaches in the guidelines.\n\n2. **String Accumulation in Loops**:\n    - The code does not accumulate strings within a loop, so there are no issues related to this aspect."}]}
{"aspect_id": 13, "aspect_guideline": "## Python Style Rules - Files, Sockets, and similar Stateful Resources\nExplicitly close files and sockets when done with them. This rule naturally extends to closeable resources that internally use sockets, such as database connections, and also other resources that need to be closed down in a similar fashion. To name only a few examples, this also includes mmap mappings, h5py File objects, and matplotlib.pyplot figure windows.\n\nThe preferred way to manage files and similar resources is using the `with` statement:\n```\nwith open(\"hello.txt\") as hello_file:\n    for line in hello_file:\n        print(line)\n```\nFor file-like objects that do not support the `with` statement, use `contextlib.closing()`:\n```\nimport contextlib\n\nwith contextlib.closing(urllib.urlopen(\"http://www.python.org/\")) as front_page:\n    for line in front_page:\n        print(line)\n```", "criteria": "1. **Explicit Resource Closure**: Verify that the code explicitly closes files, sockets, and other stateful resources when done with them. This includes resources that internally use sockets, such as database connections, as well as other resources like mmap mappings, h5py File objects, and matplotlib.pyplot figure windows.\n\n2. **Proper Resource Management**: Evaluate whether the code is using the recommended `with` statement or `contextlib.closing()` to manage resources that need to be closed down, ensuring that the resources are properly closed.\n\n3. **Handling of Exceptions**: Assess if the code is handling exceptions appropriately when dealing with files and other stateful resources, ensuring that resources are properly closed even when exceptions occur.", "demonstrations": [{"input": "```\nfrom fabric.api import env, local, cd, run, settings, sudo\n\nenv.use_ssh_config = True\nenv.hosts = ['root@skylines']\n\ndef deploy(branch='master', force=False):\n    push(branch, force)\n    restart()\n\ndef push(branch='master', force=False):\n    cmd = 'git push %s:/opt/skylines/src/ %s:master' % (env.host_string, branch)\n    if force:\n        cmd += ' --force'\n\n    local(cmd)\n\ndef restart():\n    with cd('/opt/skylines/src'):\n        run('git reset --hard')\n\n        # compile i18n .mo files\n        run('./manage.py babel compile')\n\n        # generate JS/CSS assets\n        run('./manage.py assets build')\n\n        # do database migrations\n        with settings(sudo_user='skylines'):\n            sudo('./manage.py migrate upgrade')\n\n        # restart services\n        restart_service('skylines-fastcgi')\n        restart_service('mapserver-fastcgi')\n        restart_service('skylines-daemon')\n        restart_service('celery-daemon')\n\ndef restart_service(service):\n    run('sv restart ' + service)\n\ndef load_config():\n    config_file = open('/opt/skylines/src/config.ini', 'r')\n    config_data = config_file.read()\n\n    config_lines = config_data.split('\\n')\n    for line in config_lines:\n        if line:\n            key, value = line.split('=')\n            env[key] = value\n\n# Call load_config to load additional configurations.\nload_config()\n```", "output": "1. **Explicit Resource Closure**:\n    - The code has a violation in the `load_config` function. The `config_file` resource is opened using the `open` function but is not explicitly closed afterwards. This could potentially lead to a resource leak if the function is called multiple times, or if the program runs for a long time.\n\n2. **Proper Resource Management**:\n    - In the `load_config` function, the code does not utilize the `with` statement or `contextlib.closing()` to manage the `config_file` resource. As a result, there is no guarantee that the file resource will be closed properly in all scenarios, especially in the presence of exceptions.\n\n3. **Handling of Exceptions**:\n    - The code lacks exception handling when dealing with file and stateful resource operations. For example, in the `load_config` function, if the file does not exist, the code will raise a `FileNotFoundError`. Similarly, if the configuration file's contents are not properly formatted, the code could raise a `ValueError` when attempting to split the line into a key-value pair. In the absence of proper exception handling, these scenarios would result in the termination of the entire program."}, {"input": "```\nimport logging\nimport contextlib\nimport json\n\nfrom django.conf import settings\nfrom django.utils import translation\n\nfrom celery.task import task\nfrom celery.signals import task_failure\nfrom haystack import site\nfrom sentry.client.handlers import SentryHandler\n\n# Hook up sentry to celery's logging\nlogger = logging.getLogger('task')\nlogger.addHandler(SentryHandler())\n\ndef process_failure_signal(exception, traceback, sender, task_id,\n                            signal, args, kwargs, einfo, **kw):\n    exc_info = (type(exception), exception, traceback)\n    logger.error(\n        'Celery job exception: %s(%s)' % (exception.__class__.__name__, exception),\n        exc_info=exc_info,\n        extra={\n            'data': {\n            'task_id': task_id,\n            'sender': sender,\n            'args': args,\n            'kwargs': kwargs,\n            }\n        }\n    )\ntask_failure.connect(process_failure_signal)\n\n\n@task\ndef delayed_update(instance_pk, model):\n    \"\"\" Only index stuff that is known to be public \"\"\"\n    translation.activate(settings.LANGUAGE_CODE)\n\n    try:\n        with open('config.json') as config_file:\n            config = json.load(config_file)\n            settings.update(config)\n    except (FileNotFoundError, json.JSONDecodeError):\n        logger.error(\"Error reading config file\", exc_info=True)\n\n    try:\n        instance = model.published.get(pk=instance_pk)\n    except (model.DoesNotExist, AttributeError):\n        return\n\n    site.update_object(instance)\n\n\n@task\ndef delayed_remove(instance_pk, model):\n    translation.activate(settings.LANGUAGE_CODE)\n    # Fake an instance (real one is already gone from the DB)\n    fake_instance = model()\n    fake_instance.pk = instance_pk\n    site.remove_object(fake_instance)\n```", "output": "1. **Explicit Resource Closure**:\n    - The code in the `delayed_update` function properly manages the `config_file` resource. It uses the `with` statement to open the file, ensuring that the file is automatically closed when the block of code is exited. This eliminates the risk of resource leaks and ensures that the file is closed as soon as it is no longer needed.\n\n2. **Proper Resource Management**:\n    - The code adheres to proper resource management principles. The use of the `with` statement in the `delayed_update` function ensures that the file resource is managed properly. The `with` statement automatically handles the closing of the file, even in the presence of exceptions, making it a safe and reliable way to manage resources.\n\n3. **Handling of Exceptions**:\n    - The code includes appropriate exception handling when dealing with the file and stateful resource operations. In the `delayed_update` function, the code is enclosed in a try-except block that catches `FileNotFoundError` and `json.JSONDecodeError`. This ensures that the code can handle scenarios where the file is not found or the JSON data is improperly formatted. The code also logs the error, providing valuable information for debugging purposes."}, {"input": "```\nimport json\nimport bson.json_util as bju\nimport emission.core.get_database as edb\nimport argparse\nimport emission.core.wrapper.user as ecwu\nimport os\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"timeline_filename\",\n        help=\"the name of the file that contains the json representation of the timeline\")\n    parser.add_argument(\"user_email\",\n        help=\"specify the user email to load the data as\")\n\n    parser.add_argument(\"-r\", \"--retain\", action=\"store_true\",\n        help=\"specify whether the entries should overwrite existing ones (default) or create new ones\")\n\n    parser.add_argument(\"-v\", \"--verbose\", type=int,\n        help=\"after how many lines we should print a status message.\")\n\n    args = parser.parse_args()\n    fn = args.timeline_filename\n    print(fn)\n    print(\"Loading file \" + fn)\n    tsdb = edb.get_timeseries_db()\n    user = ecwu.User.register(args.user_email)\n    override_uuid = user.uuid\n    print(\"After registration, %s -> %s\" % (args.user_email, override_uuid))\n\n    timeline_file = open(fn, 'r')\n    file_size = os.path.getsize(fn)\n    if file_size < 10:  # Arbitrary small size, could be used to skip very small files\n        print(\"File is too small, might be corrupted or empty. Exiting...\")\n        timeline_file.close()\n        exit()\n\n    entries = json.load(timeline_file, object_hook=bju.object_hook)\n    timeline_file.close()\n\n    for i, entry in enumerate(entries):\n        entry[\"user_id\"] = override_uuid\n        if not args.retain:\n            del entry[\"_id\"]\n        if args.verbose is not None and i % args.verbose == 0:\n            print(\"About to save %s\" % entry)\n        tsdb.save(entry)\n```", "output": "1. **Explicit Resource Closure**:\n    - The code correctly closes the `timeline_file` resource. By using the `close()` method after reading the file's content, it ensures that the file is not left open, which could lead to a resource leak.\n\n2. **Proper Resource Management**:\n    - The code contravenes the second aspect of the guidelines by not using the `with` statement to manage the file resource. Although the explicit open-close approach serves a specific purpose (checking the file size before reading it), it does introduce a risk. If an exception or error occurs after opening the file but before closing it, the file might remain open. This could potentially lead to resource leaks.\n\n3. **Handling of Exceptions**:\n    - The code lacks exception handling mechanisms for potential errors when dealing with the file. If the file is not in the expected format, the `json.load()` function could raise an exception. As it stands, this would prevent the file from being closed, since the `timeline_file.close()` line would be skipped. Proper exception handling would ensure that the file is always closed, regardless of whether an exception is raised."}, {"input": "```\nfrom csvkit.unicsv import UnicodeCSVReader, UnicodeCSVWriter\n\nclass CSVKitReader(UnicodeCSVReader):\n    \"\"\"\n    A unicode-aware CSV reader with some additional features.\n    \"\"\"\n    pass\n\nclass CSVKitWriter(UnicodeCSVWriter):\n    \"\"\"\n    A unicode-aware CSV writer with some additional features.\n    \"\"\"\n    def __init__(self, f, encoding='utf-8', line_numbers=False, **kwargs):\n        self.row_count = 0\n        self.line_numbers = line_numbers\n        UnicodeCSVWriter.__init__(self, f, encoding, lineterminator='\\n', **kwargs)\n\n    def _append_line_number(self, row):\n        if self.row_count == 0:\n            row.insert(0, 'line_number')\n        else:\n            row.insert(0, self.row_count)\n\n        self.row_count += 1\n\n    def writerow(self, row):\n        if self.line_numbers:\n            row = list(row)\n            self._append_line_number(row)\n\n        # Convert embedded Mac line endings to unix style line endings so they get quoted\n        row = [i.replace('\\r', '\\n') if isinstance(i, basestring) else i for i in row]\n\n        UnicodeCSVWriter.writerow(self, row)\n\n    def writerows(self, rows):\n        for row in rows:\n            self.writerow(row)\n```", "output": "1. **Explicit Resource Closure**:\n    - The code provided does not involve any explicit opening or closing of resources like files or sockets, so this aspect does not apply to this specific code.\n\n2. **Proper Resource Management**:\n    - The code does not explicitly manage any resources like files or sockets.\n\n3. **Handling of Exceptions**:\n    - Since the code is not responsible for opening and closing resources, it does not need to handle exceptions related to resource management."}]}
{"aspect_id": 14, "aspect_guideline": "## Python Style Rules - Naming\n`module_name`, `package_name`, `ClassName`, `method_name`, `ExceptionName`, `function_name`, `GLOBAL_CONSTANT_NAME`, `global_var_name`, `instance_var_name`, `function_parameter_name`, `local_var_name`, `query_proper_noun_for_thing`, `send_acronym_via_https`.\n\nFunction names, variable names, and filenames should be descriptive; avoid abbreviation. In particular, do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.\n\n### Names to Avoid\n- single character names, except for specifically allowed cases:\n    - counters or iterators (e.g. `i`, `j`, `k`, `v`, et al.)\n    - `e` as an exception identifier in `try/except` statements.\n    - `f` as a file handle in `with` statements\n    - private type variables with no constraints (e.g. `_T = TypeVar(\"_T\")`, `_P = ParamSpec(\"_P\")`)\n  Please be mindful not to abuse single-character naming. Generally speaking, descriptiveness should be proportional to the name\u2019s scope of visibility. For example, `i` might be a fine name for 5-line code block but within multiple nested scopes, it is likely too vague.\n- dashes (`-`) in any package/module name\n- `__double_leading_and_trailing_underscore__` names (reserved by Python)\n- names that needlessly include the type of the variable (for example: `id_to_name_dict`)\n\n### Naming Conventions\n- \"Internal\" means internal to a module, or protected or private within a class.\n- Prepending a single underscore (`_`) has some support for protecting module variables and functions (linters will flag protected member access).\n- Prepending a double underscore (`__` aka \u201cdunder\u201d) to an instance variable or method effectively makes the variable or method private to its class (using name mangling); we discourage its use as it impacts readability and testability, and isn\u2019t really private. Prefer a single underscore.\n- Place related classes and top-level functions together in a module. Unlike Java, there is no need to limit yourself to one class per module.\n- Use CapWords for class names, but lower_with_under.py for module names. Although there are some old modules named CapWords.py, this is now discouraged because it\u2019s confusing when the module happens to be named after a class. (\u201cwait \u2013 did I write `import StringIO` or `from StringIO import StringIO`?\u201d)", "criteria": "1. **Descriptive Naming**: Ensure that function names, variable names, and filenames are descriptive. Avoid abbreviations, especially those that are ambiguous or unfamiliar to readers outside the project.\n\n2. **Proper Naming Conventions**: Verify that the code follows the appropriate naming conventions for different types of names, including `module_name`, `package_name`, `ClassName`, `method_name`, `ExceptionName`, `function_name`, `GLOBAL_CONSTANT_NAME`, `global_var_name`, `instance_var_name`, `function_parameter_name`, `local_var_name`, `query_proper_noun_for_thing`, and `send_acronym_via_https`.\n\n3. **Avoidance of Single-Character Names**: Confirm that the code avoids single-character names, except for specifically allowed cases such as counters or iterators (`i`, `j`, `k`, `v`, etc.), `e` as an exception identifier in `try/except` statements, `f` as a file handle in `with` statements, and private type variables with no constraints (e.g. `_T = TypeVar(\"_T\")`, `_P = ParamSpec(\"_P\")`). Ensure that single-character naming is not abused, especially in larger code blocks.\n\n4. **Prohibited Names**: Check that the code does not use prohibited names, including names with dashes (`-`) in any package/module name, names with `__double_leading_and_trailing_underscore__` (reserved by Python), and names that needlessly include the type of the variable (e.g. `id_to_name_dict`).\n\n5. **Proper Use of Underscores**: Assess whether the code properly uses single and double underscores for naming. Ensure that a single underscore (`_`) is used for protecting module variables and functions, and that a double underscore (`__`) is avoided for instance variables and methods, as it impacts readability and testability.", "demonstrations": [{"input": "```\nfrom django.core.management.base import BaseCommand\nfrom dynamic_fixtures.fixtures.runner import LoadFixtureRunner\n\nclass Cmd(BaseCommand):\n\n    h = 'Load fixtures with dependencies.'\n    a = '[al] [fn]'\n\n    def add_args(self, p):\n        p.add_argument('al', type=str)\n        p.add_argument('fn', default=None, nargs='?', type=str)\n\n    def hdl(self, *a, **o):\n        r = LoadFixtureRunner()\n        n = None\n\n        if len(a) == 0:\n            if o['fn'] is None:\n                a = (o['al'], )\n            else:\n                a = (o['al'], o['fn'])\n\n        if len(a) == 1:\n            n = r.get_app_nodes(app_label=a[0])\n        elif len(a) == 2:\n            n = r.get_fixture_node(app_label=a[0], fixture_prefix=a[1])\n\n        fc = r.load_fixtures(\n            nodes=n,\n            progress_callback=self.progress_callback\n        )\n\n        self.stdout.write('Loaded {} fixtures'.format(fc))\n\n    def progress_callback(self, action, node):\n        if action == 'load_start':\n            self.stdout.write('Loading fixture {}.{}...'.format(*node),\n                              ending='')\n            self.stdout.flush()\n        elif action == 'load_success':\n            self.stdout.write('SUCCESS')\n```", "output": "1. **Descriptive Naming**:\n    - The class name `Cmd` is an abbreviation of `Command` and is less descriptive.\n    - The variable name `h` doesn't provide any context about what it represents. A better name would be `help_message`.\n    - The variable name `a` is an abbreviation and doesn't provide context about what it represents. A better name would be `arguments`.\n    - The method name `add_args` and `hdl` are abbreviations for `add_arguments` and `handle`, respectively, and are less descriptive.\n    - Variable names like `r` and `n` are not descriptive. A better name would be `runner` for `r` and `nodes` for `n`.\n\n2. **Proper Naming Conventions**:\n    - The class name `Cmd` should be named in CapWords, like `Command`.\n    - The method name `hdl` should be lowercase with words separated by underscores, like `handle`.\n    - Argument names like `p`, `al`, and `fn` should be lowercase with words separated by underscores, like `parser`, `app_label`, and `fixture_name`, respectively.\n\n3. **Avoidance of Single-Character Names**:\n    - The variables `h`, `a`, and `n` do not provide any information about their purpose. They should be renamed to `help_message`, `arguments`, and `nodes`, respectively.\n    - The parameter names `p`, `a`, and `o` in the methods `add_args` and `hdl` should be renamed to `parser`, `args`, and `options`, respectively.\n\n4. **Prohibited Names**:\n    - The code does not use prohibited names such as names with dashes, names with double leading and trailing underscores, or names that needlessly include the type of the variable.\n\n5. **Proper Use of Underscores**:\n    - The code does not violate this aspect of the guidelines. There are no variables or methods with leading underscores."}, {"input": "```\nfrom oslo_config import cfg\n\nfrom nova import test\nfrom nova.tests import fixtures as nova_fixtures\nfrom nova.tests.unit import cast_as_call\nimport nova.tests.unit.image.fake\nfrom nova.tests.unit import policy_fixture\n\nCONFIGURATION = cfg.CONF\n\nclass ServerUpdateTest(test.TestCase):\n    REQUIRES_LOCKING = True\n\n    def setUp(self):\n        super(ServerUpdateTest, self).setUp()\n        self.useFixture(policy_fixture.RealPolicyFixture())\n        # Simulate requests coming in before the instance is scheduled by\n        # using a no-op for conductor build_instances\n        self.useFixture(nova_fixtures.NoopConductorFixture())\n        api_fixture = self.useFixture(nova_fixtures.OSAPIFixture(api_version='v2.1'))\n        self.api_service = api_fixture.api\n\n        # the image fake backend needed for image discovery\n        nova.tests.unit.image.fake.stub_out_image_service(self)\n\n        self.useFixture(cast_as_call.CastAsCall(self.stubs))\n        self.addCleanup(nova.tests.unit.image.fake.FakeImageService_reset)\n\n        self.image_identifier = self.api_service.get_images()[0]['id']\n        self.flavor_identifier = self.api_service.get_flavors()[0]['id']\n\n    def test_name_update_before_scheduling(self):\n        server_data = {\n            'name': 'original_server',\n            'imageRef': self.image_identifier,\n            'flavorRef': self.flavor_identifier\n        }\n        server_id = self.api_service.post_server({'server': server_data})['id']\n        updated_server_data = {'server': {'name': 'renamed_server'}}\n        self.api_service.api_put('/servers/%s' % server_id, updated_server_data)\n        updated_server_name = self.api_service.get_server(server_id)['name']\n        self.assertEqual('renamed_server', updated_server_name)\n```", "output": "1. **Descriptive Naming**:\n   - The code uses descriptive names such as `ServerUpdateTest`, `server_data`, and `test_name_update_before_scheduling`, which clearly indicate their purpose.\n\n2. **Proper Naming Conventions**:\n   - The class name `ServerUpdateTest` aligns well with the `ClassName` naming convention.\n   - All method names and variable names within the class and methods are lowercase with words separated by underscores, adhering to the convention for method names and variable names.\n   - Constants like `CONFIGURATION` follow the convention of being all uppercase with words separated by underscores.\n\n3. **Avoidance of Single-Character Names**:\n   - The code steers clear of single-character variable names, which aids readability and clarity.\n\n4. **Prohibited Names**:\n   - The code steers clear of any prohibited names. This ensures better compatibility and less confusion with Python's reserved names or conventions.\n\n5. **Proper Use of Underscores**:\n   - The code does not violate this aspect of the guidelines. There are no variables or methods with leading underscores."}, {"input": "```\nfrom __future__ import division\nfrom __future__ import unicode_literals\n\nfrom decimal import Decimal\n\nimport requests\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\n\nfrom .models import ConversionRate\n\nurl_base = r'http://openexchangerates.org/api'\nendpt = url_base + r'/latest.json'\ntry:\n    k = settings.OPENEXCHANGERATES_API_KEY\nexcept AttributeError:\n    raise ImproperlyConfigured('OPENEXCHANGERATES_API_KEY is required')\n\ndef rate_extract(r, c):\n    b = r[settings.DEFAULT_CURRENCY]\n    return r[c] / b\n\ndef latest_rates_fetch():\n    res = requests.get(endpt, params={'app_id': k})\n    res.raise_for_status()\n    return res.json(parse_int=Decimal, parse_float=Decimal)\n\ndef conversion_rates_upd():\n    ex_rates = latest_rates_fetch()\n    conv_rates = ConversionRate.objects.all()\n    for cr in conv_rates:\n        new_rate = rate_extract(ex_rates, cr.to_currency)\n        cr.rate = new_rate\n        cr.save(update_fields=['rate_dict'])\n    return conv_rates\n```", "output": "1. **Descriptive Naming**:\n   - The variable name `endpt` is an abbreviation of `endpoint` and is less descriptive.\n   - The function name `conversion_rates_upd` is an abbreviation of `conversion_rates_update`, and is less descriptive.\n   - The variable names `r` and `c` in the function `rate_extract` do not provide context about what they represent.\n   - The variable name `cr` in the function `conversion_rates_upd` is an abbreviation and doesn't provide context about what it represents. A better name would be `conversion_rate`.\n\n2. **Proper Naming Conventions**:\n   - The code uses proper naming conventions for class names, method names, and variable names. For example, `latest_rates_fetch` is named in lowercase with words separated by underscores.\n\n3. **Avoidance of Single-Character Names**:\n   - The variable name `k` does not provide any information about its purpose. It should be renamed to `api_key`.\n   - The variables `r`, `c`, `b`, and `cr` do not provide any information about their purpose.\n\n4. **Prohibited Names**:\n   - The line `cr.save(update_fields=['rate_dict'])` violates the guidelines. The name `rate_dict` needlessly includes the type of the variable.\n\n5. **Proper Use of Underscores**:\n    - The code does not violate this aspect of the guidelines. There are no variables or methods with leading underscores."}, {"input": "```\nimport subprocess\nimport netaddr\nimport lglass.route\n\nclass BirdClient:\n    def __init__(self, executable_path=\"birdc\"):\n        self.executable_path = executable_path\n\n    def send_command(self, command, is_raw=False):\n        command_args = [self.executable_path]\n        if is_raw:\n            command_args.append(\"-v\")\n        if isinstance(command, str):\n            command_args.extend(command.split())\n        else:\n            command_args.extend(command)\n        process = subprocess.Popen(\n            command_args, stdout=subprocess.PIPE, stdin=subprocess.DEVNULL, stderr=subprocess.PIPE)\n        data = b\"\"\n        while True:\n            received_data = process.stdout.read()\n            if len(received_data) == 0:\n                break\n            data += received_data\n        process.wait()\n        return data.split(b\"\\n\", 1)[1]\n\n    def retrieve_routes(self, table=None, protocol=None, primary=False, show_all=True, filtered=False):\n        command = [\"show\", \"route\"]\n        if table is not None:\n            command.append(\"table\")\n            command.append(str(table))\n        if show_all:\n            command.append(\"all\")\n        if primary:\n            command.append(\"primary\")\n        if filtered:\n            command.append(\"filtered\")\n        if protocol is not None:\n            command.append(str(protocol))\n        response = self.send_command(command)\n        return list(parse_routes(response.decode().splitlines()))\n\n    def list_protocols(self):\n        command = [\"show\", \"protocols\"]\n        response = self.send_command(command)\n        for line in response.splitlines()[1:]:\n            fields = line.decode().split()\n            while len(fields) < 7:\n                fields.append(None)\n            yield tuple(fields)\n\ndef parse_routes(lines):\n    lines_iterator = iter(lines)\n    current_prefix = None\n    current_route = None\n\n    for line in lines_iterator:\n        if line[0] == \"\\t\":\n            # Route annotation\n            key, value = line.split(\":\", 1)\n            current_route[key.strip()] = value.strip()\n            continue\n\n        if current_route is not None:\n            yield current_route\n\n        if line[0] != \" \":\n            current_prefix, *args = line.split()\n        else:\n            args = line.split()\n\n        current_route = lglass.route.Route(current_prefix)\n\n        if args[0] == \"via\":\n            current_route.nexthop = (netaddr.IPAddress(args[1]), args[3])\n\n        if args[-2][0] == \"(\" and args[-2][-1] == \")\":\n            metric = args[-2][1:-1]\n            if \"/\" in metric:\n                metric = metric.split(\"/\", 1)[0]\n            current_route.metric = int(metric)\n\n    if current_route is not None:\n        yield current_route\n```", "output": "1. **Descriptive Naming**:\n   - In the code snippet, all variable and function names are descriptive and provide context about what they represent, improving code readability.\n   - Examples include `BirdClient`, `executable_path`, `send_command`, `retrieve_routes`, and `list_protocols`.\n\n2. **Proper Naming Conventions**:\n   - The class name `BirdClient` follows the CapWords convention for class names.\n   - All method and variable names within the class are lowercase with words separated by underscores, adhering to the convention for method names and variable names.\n\n3. **Avoidance of Single-Character Names**:\n   - The code does not have any single-character variable names, which enhances code clarity.\n\n4. **Prohibited Names**:\n   - The code does not use prohibited names, such as names with dashes, names with double leading and trailing underscores, or names that needlessly include the type of the variable.\n\n5. **Proper Use of Underscores**:\n   - The code does not violate this aspect of the guidelines. There are no variables or methods with leading underscores."}]}
